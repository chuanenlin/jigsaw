{"ast":null,"code":"import _applyDecoratedDescriptor from \"/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nvar _dec, _class;\nimport { blockRequestProcessors, generateBlockParams, transformParam } from '../api';\nimport { BlockProcessStatus } from '../context/WorkspaceContext';\nimport { uploadFile } from '../api/upload';\nimport { Modality } from '../types';\nimport { cached, transformNested } from '../utils';\n\n// type ImmediatePredecessors = Map<string, ProcessableBlock>\n\nexport let BlockProcessorService = (_dec = cached({\n  clearPaths: {\n    0: ['blocklyBlock.id']\n  },\n  comparePaths: {\n    0: ['inputs', 'blockData.blockParameters.model']\n  }\n}), (_class = class BlockProcessorService {\n  constructor(onBlockStatusChanged) {\n    /**\n     * Callback function that is called when a block is processed.\n     * This is used to update the block's process status in the UI.\n     */\n    this.onBlockStatusChanged = void 0;\n    this.processedBlocksCount = 0;\n    this.canceled = false;\n    /**\n     * Uploads the input data to the server and returns the url\n     * @param block - The block to process\n     * @param inputData - The input data of the block\n     */\n    this.getInputBlockOutput = async (block, inputData) => {\n      const modality = block.blockData.outputModality;\n      if (modality === Modality.Image) {\n        const uploadResponse = await uploadFile(inputData, modality);\n        return {\n          // eslint-disable-next-line camelcase\n          image_output: uploadResponse.file_url\n        };\n      } else if (modality === Modality.Audio) {\n        const uploadResponse = await uploadFile(inputData, modality);\n        return {\n          // eslint-disable-next-line camelcase\n          audio_output: uploadResponse.file_url\n        };\n      } else if (modality === Modality.Video) {\n        const uploadResponse = await uploadFile(inputData, modality);\n        return {\n          // eslint-disable-next-line camelcase\n          video_output: uploadResponse.file_url\n        };\n      } else if (modality === Modality.ThreeDimentional) {\n        const uploadResponse = await uploadFile(inputData, modality);\n        return {\n          // eslint-disable-next-line camelcase\n          '3d_response': uploadResponse.file_url\n        };\n      }\n      return {\n        // eslint-disable-next-line camelcase\n        text_output: inputData.content\n      };\n    };\n    this.getInputAlias = block => {\n      var _block$blocklyBlock$o, _block$blocklyBlock$o2;\n      if (!block) {\n        return null;\n      }\n      const check = (_block$blocklyBlock$o = block.blocklyBlock.outputConnection) === null || _block$blocklyBlock$o === void 0 ? void 0 : (_block$blocklyBlock$o2 = _block$blocklyBlock$o.targetConnection) === null || _block$blocklyBlock$o2 === void 0 ? void 0 : _block$blocklyBlock$o2.getCheck();\n      if (!(check !== null && check !== void 0 && check.length)) {\n        return null;\n      }\n      if (check.length > 1) {\n        return check[1];\n      }\n      return check[0];\n    };\n    this.onBlockStatusChanged = onBlockStatusChanged;\n  }\n\n  /**\n   * Process a chain of blocks.\n   * The process is done recursively, starting from the last block in the chain.\n   * @param blocks - Map of blocks\n   */\n  async initiateProcessing(blocks, selectedBlocklyBlockId) {\n    const chainWithInputNode = this.findChainWithInputNode(blocks, selectedBlocklyBlockId);\n\n    // Restore state of the blocks in the current chain\n    // TODO: should handle differently if we want to re-run only if params are changed.\n    chainWithInputNode.forEach(block => {\n      block.output = undefined;\n      block.processStatus = BlockProcessStatus.IDLE;\n    });\n    await this.processChain(this.findLastBlockInTheChain(chainWithInputNode), chainWithInputNode);\n  }\n  cancelProcessing() {\n    this.canceled = true;\n  }\n\n  /**\n   * Process a block and its input blocks recursively\n   * The input blocks are processed first and their outputs are used as inputs for the block\n   * @param block - The block to process\n   * @param allBlocks - Map of all blocks\n   */\n  async processChain(block, allBlocks) {\n    var _this$onBlockStatusCh;\n    // if (block.output) {\n    //   return block.output\n    // }\n\n    const immediatePredecessors = this.findImmediatePredecessors(block, allBlocks);\n    let inputs = {};\n    /**\n     * If the block has no input blocks, this is the first block in the chain\n     * so we use the block's inputs.\n     * The inputs of the first block should always be set before processing a chain.\n     */\n    if (immediatePredecessors.length === 0) {\n      // TODO: uncomment once we have a way to set the inputs of the first block\n      // first block would never have inputs as it is the inout block, look todo bellow\n      //   if (!block.inputs) {\n      //     throw new Error('Input for first block not found')\n      //   }\n\n      inputs = block.inputs;\n    }\n\n    /**\n     * If not first block in the chain, process the input blocks first\n     * The input blocks are processed in parallel\n     */\n    const promises = [];\n    for (const {\n      type,\n      block,\n      inputAlias\n    } of immediatePredecessors) {\n      // The then function is used to associate the type with the corresponding input for each processBlock call.\n      // This is necessary because Promise.all does not preserve the order of the results, so you can't simply\n      // associate the inputs with their types based on their position in the array.\n      const promise = this.processChain(block, allBlocks).then(value => ({\n        type,\n        value,\n        block,\n        inputAlias\n      }));\n      promises.push(promise);\n    }\n    const results = await Promise.all(promises);\n    if (this.canceled) {\n      return;\n    }\n    for (const result of results) {\n      if (result.value) {\n        inputs = {\n          ...inputs,\n          [result.inputAlias || result.type]: result.value\n        };\n      }\n    }\n    block.inputs = inputs;\n    block.processStatus = BlockProcessStatus.STARTED;\n    (_this$onBlockStatusCh = this.onBlockStatusChanged) === null || _this$onBlockStatusCh === void 0 ? void 0 : _this$onBlockStatusCh.call(this, block, Array.from(allBlocks.values()).filter(block => block.blockData.blockType === 'llm').length, this.processedBlocksCount);\n    try {\n      if (block.blockData.blockType === 'input') {\n        var _block$inputs;\n        const inputResponse = (_block$inputs = block.inputs) === null || _block$inputs === void 0 ? void 0 : _block$inputs[block.blockData.outputModality];\n        if (!inputResponse) {\n          throw new Error(`Input not found for ${block.blockData.name} block.`);\n        }\n        return this.getInputBlockOutput(block, inputResponse);\n      }\n      const output = await this.processBlock(block);\n      block.processStatus = BlockProcessStatus.FINISHED;\n      block.output = output;\n      return output;\n    } catch (error) {\n      block.processStatus = BlockProcessStatus.FAILED;\n      throw error;\n    } finally {\n      var _this$onBlockStatusCh2;\n      if (block.blockData.blockType === 'llm') {\n        this.processedBlocksCount++;\n      }\n      (_this$onBlockStatusCh2 = this.onBlockStatusChanged) === null || _this$onBlockStatusCh2 === void 0 ? void 0 : _this$onBlockStatusCh2.call(this, block, allBlocks.size, this.processedBlocksCount);\n    }\n  }\n\n  /**\n   * Generates the params for the block and calls the corresponding endpoint.\n   * @params block - The block to process\n   */\n  async processBlock(block) {\n    const params = generateBlockParams(block);\n    const transformedParams = await transformNested(params, transformParam);\n    if (!transformedParams) {\n      throw new Error('transformedParams is required');\n    }\n    if (!block.blockData.endpointName || !blockRequestProcessors[block.blockData.endpointName]) {\n      throw new Error('Incorrect block process endpoint');\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return blockRequestProcessors[block.blockData.endpointName](transformedParams);\n  }\n\n  /**\n   * Find the immediate predecessors (input blocks) of a block\n   * @param block - The block to find the immediate predecessors of\n   * @param blocks - Map of blocks\n   */\n  findImmediatePredecessors(block, blocks) {\n    const inputs = block.blocklyBlock.inputList;\n    if (!inputs) {\n      return new Array();\n    }\n    const immediatePredecessors = [];\n    inputs.forEach(input => {\n      var _input$connection, _input$connection$tar;\n      const blockId = (_input$connection = input.connection) === null || _input$connection === void 0 ? void 0 : (_input$connection$tar = _input$connection.targetBlock()) === null || _input$connection$tar === void 0 ? void 0 : _input$connection$tar.id;\n      const type = input.name;\n      if (blockId && blocks.get(blockId)) {\n        immediatePredecessors.push({\n          type,\n          block: blocks.get(blockId),\n          inputAlias: this.getInputAlias(blocks.get(blockId))\n        });\n      }\n    });\n    return immediatePredecessors;\n  }\n\n  /**\n   * Returns the chain of blocks that include an input node.\n   * At the time being only one input block is allowed in the workspace\n   * @param blocks\n   * @returns\n   */\n  findChainWithInputNode(blocks, selectedBlocklyBlockId) {\n    const allBlocks = Array.from(blocks.values());\n    const inputBlocks = allBlocks.filter(block => block.blockData.blockType === 'input');\n    if (inputBlocks.length === 0) {\n      throw new Error('No input blocks were found');\n    } else if (inputBlocks.length > 2 && !selectedBlocklyBlockId) {\n      throw new Error('More than one chain detected: please select the chain you want to run');\n    } else if (inputBlocks.length === 2) {\n      // find the roots and see if they're the same\n      const root1 = inputBlocks[0].blocklyBlock.getRootBlock();\n      const root2 = inputBlocks[1].blocklyBlock.getRootBlock();\n      if (root1.id !== root2.id && !selectedBlocklyBlockId) {\n        // more than one list exist and none is selected\n        throw new Error('More than one chain detected: please select the chain you want to run');\n      }\n    }\n    const identifierBlock = !selectedBlocklyBlockId ? inputBlocks[0] : allBlocks.find(block => block.blocklyBlock.id === selectedBlocklyBlockId);\n    if (!identifierBlock) {\n      throw new Error('Something went wrong!');\n    }\n\n    // find all blocks attached to the identifier block\n    const rootBlock = identifierBlock.blocklyBlock.getRootBlock();\n    const descendants = rootBlock === null || rootBlock === void 0 ? void 0 : rootBlock.getDescendants(false); // this includes the root\n\n    const chainWithInput = new Map();\n    descendants.map(descendant => {\n      const block = blocks.get(descendant.id);\n      if (block) {\n        chainWithInput.set(descendant.id, block);\n      }\n    });\n    if (!chainWithInput) {\n      throw new Error('Chain with input not found');\n    }\n    return chainWithInput;\n  }\n\n  /**\n   * Find the last block in the chain (the block that isn't input to any other block)\n   * @param blocks Map of blocks\n   * @returns The last block in the chain\n   */\n  findLastBlockInTheChain(blocks) {\n    const lastBlock = Array.from(blocks.values()).find(block => {\n      var _block$blocklyBlock$o3;\n      return !((_block$blocklyBlock$o3 = block.blocklyBlock.outputConnection) !== null && _block$blocklyBlock$o3 !== void 0 && _block$blocklyBlock$o3.targetBlock());\n    });\n    if (!lastBlock) {\n      throw new Error('Last block not found');\n    }\n    return lastBlock;\n  }\n}, (_applyDecoratedDescriptor(_class.prototype, \"processBlock\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"processBlock\"), _class.prototype)), _class));","map":{"version":3,"names":["blockRequestProcessors","generateBlockParams","transformParam","BlockProcessStatus","uploadFile","Modality","cached","transformNested","BlockProcessorService","_dec","clearPaths","comparePaths","_class","constructor","onBlockStatusChanged","processedBlocksCount","canceled","getInputBlockOutput","block","inputData","modality","blockData","outputModality","Image","uploadResponse","image_output","file_url","Audio","audio_output","Video","video_output","ThreeDimentional","text_output","content","getInputAlias","_block$blocklyBlock$o","_block$blocklyBlock$o2","check","blocklyBlock","outputConnection","targetConnection","getCheck","length","initiateProcessing","blocks","selectedBlocklyBlockId","chainWithInputNode","findChainWithInputNode","forEach","output","undefined","processStatus","IDLE","processChain","findLastBlockInTheChain","cancelProcessing","allBlocks","_this$onBlockStatusCh","immediatePredecessors","findImmediatePredecessors","inputs","promises","type","inputAlias","promise","then","value","push","results","Promise","all","result","STARTED","call","Array","from","values","filter","blockType","_block$inputs","inputResponse","Error","name","processBlock","FINISHED","error","FAILED","_this$onBlockStatusCh2","size","params","transformedParams","endpointName","inputList","input","_input$connection","_input$connection$tar","blockId","connection","targetBlock","id","get","inputBlocks","root1","getRootBlock","root2","identifierBlock","find","rootBlock","descendants","getDescendants","chainWithInput","Map","map","descendant","set","lastBlock","_block$blocklyBlock$o3","_applyDecoratedDescriptor","prototype","Object","getOwnPropertyDescriptor"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/service/block.process.service.ts"],"sourcesContent":["import {\n  A3dResponse,\n  AudioResponse,\n  blockRequestProcessors,\n  BlockResponse,\n  generateBlockParams,\n  ImageResponse,\n  InputBlockResponse,\n  SelectedFile,\n  TextResponse,\n  transformParam,\n  VideoResponse,\n} from '../api'\nimport {\n  BlockProcessInputs,\n  BlockProcessStatus,\n  ProcessableBlock,\n} from '../context/WorkspaceContext'\nimport { uploadFile } from '../api/upload'\nimport { Modality } from '../types'\nimport { cached, transformNested } from '../utils'\n\n// type ImmediatePredecessors = Map<string, ProcessableBlock>\ntype ImmediatePredecessors = { type: string; block: ProcessableBlock; inputAlias: string | null }\n\ntype BlockStatusCallback = (\n  block: ProcessableBlock,\n  blockCount: number,\n  processedBlocksCount: number,\n) => void\n\nexport class BlockProcessorService {\n  /**\n   * Callback function that is called when a block is processed.\n   * This is used to update the block's process status in the UI.\n   */\n  private onBlockStatusChanged?: BlockStatusCallback\n\n  private processedBlocksCount = 0\n\n  private canceled = false\n\n  constructor(onBlockStatusChanged: BlockStatusCallback) {\n    this.onBlockStatusChanged = onBlockStatusChanged\n  }\n\n  /**\n   * Process a chain of blocks.\n   * The process is done recursively, starting from the last block in the chain.\n   * @param blocks - Map of blocks\n   */\n  public async initiateProcessing(\n    blocks: Map<string, ProcessableBlock>,\n    selectedBlocklyBlockId: string | undefined | null,\n  ) {\n    const chainWithInputNode = this.findChainWithInputNode(blocks, selectedBlocklyBlockId)\n\n    // Restore state of the blocks in the current chain\n    // TODO: should handle differently if we want to re-run only if params are changed.\n    chainWithInputNode.forEach((block) => {\n      block.output = undefined\n      block.processStatus = BlockProcessStatus.IDLE\n    })\n\n    await this.processChain(this.findLastBlockInTheChain(chainWithInputNode), chainWithInputNode)\n  }\n\n  public cancelProcessing() {\n    this.canceled = true\n  }\n\n  /**\n   * Process a block and its input blocks recursively\n   * The input blocks are processed first and their outputs are used as inputs for the block\n   * @param block - The block to process\n   * @param allBlocks - Map of all blocks\n   */\n  private async processChain(\n    block: ProcessableBlock,\n    allBlocks: Map<string, ProcessableBlock>,\n  ): Promise<BlockResponse | undefined> {\n    // if (block.output) {\n    //   return block.output\n    // }\n\n    const immediatePredecessors = this.findImmediatePredecessors(block, allBlocks)\n\n    let inputs: BlockProcessInputs = {}\n    /**\n     * If the block has no input blocks, this is the first block in the chain\n     * so we use the block's inputs.\n     * The inputs of the first block should always be set before processing a chain.\n     */\n    if (immediatePredecessors.length === 0) {\n      // TODO: uncomment once we have a way to set the inputs of the first block\n      // first block would never have inputs as it is the inout block, look todo bellow\n      //   if (!block.inputs) {\n      //     throw new Error('Input for first block not found')\n      //   }\n\n      inputs = block.inputs!\n    }\n\n    /**\n     * If not first block in the chain, process the input blocks first\n     * The input blocks are processed in parallel\n     */\n    const promises = []\n    for (const { type, block, inputAlias } of immediatePredecessors) {\n      // The then function is used to associate the type with the corresponding input for each processBlock call.\n      // This is necessary because Promise.all does not preserve the order of the results, so you can't simply\n      // associate the inputs with their types based on their position in the array.\n      const promise = this.processChain(block, allBlocks).then((value) => ({\n        type,\n        value,\n        block,\n        inputAlias,\n      }))\n      promises.push(promise)\n    }\n\n    const results = await Promise.all(promises)\n\n    if (this.canceled) {\n      return\n    }\n\n    for (const result of results) {\n      if (result.value) {\n        inputs = { ...inputs, [result.inputAlias || result.type]: result.value }\n      }\n    }\n\n    block.inputs = inputs\n    block.processStatus = BlockProcessStatus.STARTED\n    this.onBlockStatusChanged?.(\n      block,\n      Array.from(allBlocks.values()).filter((block) => block.blockData.blockType === 'llm').length,\n      this.processedBlocksCount,\n    )\n\n    try {\n      if (block.blockData.blockType === 'input') {\n        const inputResponse = block.inputs?.[block.blockData.outputModality] as\n          | InputBlockResponse\n          | undefined\n\n        if (!inputResponse) {\n          throw new Error(`Input not found for ${block.blockData.name} block.`)\n        }\n\n        return this.getInputBlockOutput(block, inputResponse)\n      }\n\n      const output = await this.processBlock(block)\n\n      block.processStatus = BlockProcessStatus.FINISHED\n      block.output = output\n\n      return output\n    } catch (error) {\n      block.processStatus = BlockProcessStatus.FAILED\n      throw error\n    } finally {\n      if (block.blockData.blockType === 'llm') {\n        this.processedBlocksCount++\n      }\n      this.onBlockStatusChanged?.(block, allBlocks.size, this.processedBlocksCount)\n    }\n  }\n\n  /**\n   * Generates the params for the block and calls the corresponding endpoint.\n   * @params block - The block to process\n   */\n  @cached({\n    clearPaths: {\n      0: ['blocklyBlock.id'],\n    },\n    comparePaths: {\n      0: ['inputs', 'blockData.blockParameters.model'],\n    },\n  })\n  async processBlock(block: ProcessableBlock) {\n    const params = generateBlockParams(block)\n\n    const transformedParams = await transformNested(params, transformParam)\n\n    if (!transformedParams) {\n      throw new Error('transformedParams is required')\n    }\n\n    if (!block.blockData.endpointName || !blockRequestProcessors[block.blockData.endpointName]) {\n      throw new Error('Incorrect block process endpoint')\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return blockRequestProcessors[block.blockData.endpointName](transformedParams as any)\n  }\n\n  /**\n   * Find the immediate predecessors (input blocks) of a block\n   * @param block - The block to find the immediate predecessors of\n   * @param blocks - Map of blocks\n   */\n  private findImmediatePredecessors(\n    block: ProcessableBlock,\n    blocks: Map<string, ProcessableBlock>,\n  ): Array<ImmediatePredecessors> {\n    const inputs = block.blocklyBlock.inputList\n\n    if (!inputs) {\n      return new Array<ImmediatePredecessors>()\n    }\n\n    const immediatePredecessors: Array<ImmediatePredecessors> = []\n\n    inputs.forEach((input) => {\n      const blockId = input.connection?.targetBlock()?.id\n      const type = input.name\n\n      if (blockId && blocks.get(blockId)) {\n        immediatePredecessors.push({\n          type,\n          block: blocks.get(blockId) as ProcessableBlock,\n          inputAlias: this.getInputAlias(blocks.get(blockId)),\n        })\n      }\n    })\n\n    return immediatePredecessors\n  }\n\n  /**\n   * Returns the chain of blocks that include an input node.\n   * At the time being only one input block is allowed in the workspace\n   * @param blocks\n   * @returns\n   */\n  private findChainWithInputNode(\n    blocks: Map<string, ProcessableBlock>,\n    selectedBlocklyBlockId: string | undefined | null,\n  ) {\n    const allBlocks = Array.from(blocks.values())\n    const inputBlocks = allBlocks.filter((block) => block.blockData.blockType === 'input')\n\n    if (inputBlocks.length === 0) {\n      throw new Error('No input blocks were found')\n    } else if (inputBlocks.length > 2 && !selectedBlocklyBlockId) {\n      throw new Error('More than one chain detected: please select the chain you want to run')\n    } else if (inputBlocks.length === 2) {\n      // find the roots and see if they're the same\n      const root1 = inputBlocks[0].blocklyBlock.getRootBlock()\n      const root2 = inputBlocks[1].blocklyBlock.getRootBlock()\n\n      if (root1.id !== root2.id && !selectedBlocklyBlockId) {\n        // more than one list exist and none is selected\n        throw new Error('More than one chain detected: please select the chain you want to run')\n      }\n    }\n\n    const identifierBlock = !selectedBlocklyBlockId\n      ? inputBlocks[0]\n      : allBlocks.find((block) => block.blocklyBlock.id === selectedBlocklyBlockId)\n\n    if (!identifierBlock) {\n      throw new Error('Something went wrong!')\n    }\n\n    // find all blocks attached to the identifier block\n    const rootBlock = identifierBlock.blocklyBlock.getRootBlock()\n    const descendants = rootBlock?.getDescendants(false) // this includes the root\n\n    const chainWithInput = new Map<string, ProcessableBlock>()\n    descendants.map((descendant) => {\n      const block = blocks.get(descendant.id)\n      if (block) {\n        chainWithInput.set(descendant.id, block)\n      }\n    })\n\n    if (!chainWithInput) {\n      throw new Error('Chain with input not found')\n    }\n\n    return chainWithInput\n  }\n\n  /**\n   * Find the last block in the chain (the block that isn't input to any other block)\n   * @param blocks Map of blocks\n   * @returns The last block in the chain\n   */\n  private findLastBlockInTheChain(blocks: Map<string, ProcessableBlock>) {\n    const lastBlock = Array.from(blocks.values()).find(\n      (block) => !block.blocklyBlock.outputConnection?.targetBlock(),\n    )\n    if (!lastBlock) {\n      throw new Error('Last block not found')\n    }\n\n    return lastBlock\n  }\n\n  /**\n   * Uploads the input data to the server and returns the url\n   * @param block - The block to process\n   * @param inputData - The input data of the block\n   */\n  private getInputBlockOutput = async (block: ProcessableBlock, inputData: SelectedFile) => {\n    const modality = block.blockData.outputModality\n    if (modality === Modality.Image) {\n      const uploadResponse = await uploadFile(inputData, modality)\n      return {\n        // eslint-disable-next-line camelcase\n        image_output: uploadResponse.file_url,\n      } as ImageResponse\n    } else if (modality === Modality.Audio) {\n      const uploadResponse = await uploadFile(inputData, modality)\n      return {\n        // eslint-disable-next-line camelcase\n        audio_output: uploadResponse.file_url,\n      } as AudioResponse\n    } else if (modality === Modality.Video) {\n      const uploadResponse = await uploadFile(inputData, modality)\n      return {\n        // eslint-disable-next-line camelcase\n        video_output: uploadResponse.file_url,\n      } as VideoResponse\n    } else if (modality === Modality.ThreeDimentional) {\n      const uploadResponse = await uploadFile(inputData, modality)\n      return {\n        // eslint-disable-next-line camelcase\n        '3d_response': uploadResponse.file_url,\n      } as A3dResponse\n    }\n\n    return {\n      // eslint-disable-next-line camelcase\n      text_output: inputData.content,\n    } as TextResponse\n  }\n\n  private getInputAlias = (block?: ProcessableBlock) => {\n    if (!block) {\n      return null\n    }\n\n    const check = block.blocklyBlock.outputConnection?.targetConnection?.getCheck()\n\n    if (!check?.length) {\n      return null\n    }\n\n    if (check.length > 1) {\n      return check[1]\n    }\n\n    return check[0]\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}