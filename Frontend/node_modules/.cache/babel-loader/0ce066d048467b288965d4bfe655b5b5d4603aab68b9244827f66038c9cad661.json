{"ast":null,"code":"import { useState, useCallback } from 'react';\nimport { fromEvent } from 'file-selector';\nfunction _regeneratorRuntime() {\n  _regeneratorRuntime = function () {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function (method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function () {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    catch: function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar BYTES_PER_MEGABYTE = 1000000;\nvar FileSizeValidator = /*#__PURE__*/function () {\n  function FileSizeValidator() {}\n  var _proto = FileSizeValidator.prototype;\n  _proto.validateBeforeParsing = /*#__PURE__*/function () {\n    var _validateBeforeParsing = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(config, plainFiles) {\n      var minFileSize, maxFileSize, errors;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            minFileSize = config.minFileSize, maxFileSize = config.maxFileSize;\n            if (!(!minFileSize && !maxFileSize)) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt(\"return\", Promise.resolve());\n          case 3:\n            errors = plainFiles.map(function (file) {\n              return getFileSizeError({\n                minFileSize: minFileSize,\n                maxFileSize: maxFileSize,\n                fileSize: file.size\n              });\n            }).filter(function (error) {\n              return !!error;\n            });\n            return _context.abrupt(\"return\", errors.length > 0 ? Promise.reject(errors[0]) : Promise.resolve());\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function validateBeforeParsing(_x, _x2) {\n      return _validateBeforeParsing.apply(this, arguments);\n    }\n    return validateBeforeParsing;\n  }();\n  _proto.validateAfterParsing = /*#__PURE__*/function () {\n    var _validateAfterParsing = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_config, _file) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", Promise.resolve());\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    function validateAfterParsing(_x3, _x4) {\n      return _validateAfterParsing.apply(this, arguments);\n    }\n    return validateAfterParsing;\n  }();\n  return FileSizeValidator;\n}();\nvar getFileSizeError = function getFileSizeError(_ref) {\n  var fileSize = _ref.fileSize,\n    maxFileSize = _ref.maxFileSize,\n    minFileSize = _ref.minFileSize;\n  if (minFileSize) {\n    var minBytes = minFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize < minBytes) {\n      return {\n        fileSizeTooSmall: true\n      };\n    }\n  }\n  if (maxFileSize) {\n    var maxBytes = maxFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize > maxBytes) {\n      return {\n        fileSizeToolarge: true\n      };\n    }\n  }\n};\nvar FilesLimitValidator = /*#__PURE__*/function () {\n  function FilesLimitValidator() {}\n  var _proto = FilesLimitValidator.prototype;\n  _proto.validateBeforeParsing = function validateBeforeParsing(config, plainFiles) {\n    var limitFilesConfig = config.limitFilesConfig;\n    if (limitFilesConfig) {\n      if (limitFilesConfig.max && plainFiles.length > limitFilesConfig.max) {\n        return Promise.reject({\n          maxLimitExceeded: true\n        });\n      }\n      if (limitFilesConfig.min && plainFiles.length < limitFilesConfig.min) {\n        return Promise.reject({\n          minLimitNotReached: true\n        });\n      }\n    }\n    return Promise.resolve();\n  };\n  _proto.validateAfterParsing = function validateAfterParsing() {\n    return Promise.resolve();\n  };\n  return FilesLimitValidator;\n}();\nfunction openFileDialog(accept, multiple, callback, initializeWithCustomAttributes) {\n  // this function must be called from a user\n  // activation event (ie an onclick event)\n  // Create an input element\n  var inputElement = document.createElement('input');\n  // Hide element and append to body (required to run on iOS safari)\n  inputElement.style.display = 'none';\n  document.body.appendChild(inputElement);\n  // Set its type to file\n  inputElement.type = 'file';\n  // Set accept to the file types you want the user to select.\n  // Include both the file extension and the mime type\n  // if accept is \"*\" then dont set the accept attribute\n  if (accept !== '*') inputElement.accept = accept;\n  // Accept multiple files\n  inputElement.multiple = multiple;\n  // set onchange event to call callback when user has selected file\n  //inputElement.addEventListener('change', callback);\n  inputElement.addEventListener('change', function (arg) {\n    callback(arg);\n    // remove element\n    document.body.removeChild(inputElement);\n  });\n  if (initializeWithCustomAttributes) {\n    initializeWithCustomAttributes(inputElement);\n  }\n  // dispatch a click event to open the file dialog\n  inputElement.dispatchEvent(new MouseEvent('click'));\n}\nvar ImageDimensionsValidator = /*#__PURE__*/function () {\n  function ImageDimensionsValidator() {}\n  var _proto = ImageDimensionsValidator.prototype;\n  _proto.validateBeforeParsing = function validateBeforeParsing() {\n    return Promise.resolve();\n  };\n  _proto.validateAfterParsing = function validateAfterParsing(config, file, reader) {\n    var readAs = config.readAs,\n      imageSizeRestrictions = config.imageSizeRestrictions;\n    if (readAs === 'DataURL' && imageSizeRestrictions && isImage(file.type)) {\n      return checkImageDimensions(reader.result, imageSizeRestrictions);\n    }\n    return Promise.resolve();\n  };\n  return ImageDimensionsValidator;\n}();\nvar isImage = function isImage(fileType) {\n  return fileType.startsWith('image');\n};\nvar checkImageDimensions = function checkImageDimensions(imgDataURL, imageSizeRestrictions) {\n  return new Promise(function (resolve, reject) {\n    var img = new Image();\n    img.onload = function () {\n      var maxHeight = imageSizeRestrictions.maxHeight,\n        maxWidth = imageSizeRestrictions.maxWidth,\n        minHeight = imageSizeRestrictions.minHeight,\n        minWidth = imageSizeRestrictions.minWidth;\n      var width = this.width,\n        height = this.height;\n      var errors = {};\n      if (maxHeight && maxHeight < height) errors = _extends({}, errors, {\n        imageHeightTooBig: true\n      });\n      if (minHeight && minHeight > height) errors = _extends({}, errors, {\n        imageHeightTooSmall: true\n      });\n      if (maxWidth && maxWidth < width) errors = _extends({}, errors, {\n        imageWidthTooBig: true\n      });\n      if (minWidth && minWidth > width) errors = _extends({}, errors, {\n        imageWidthTooSmall: true\n      });\n      Object.keys(errors).length ? reject(errors) : resolve();\n    };\n    img.onerror = function () {\n      reject({\n        imageNotLoaded: true\n      });\n    };\n    img.src = imgDataURL;\n  });\n};\nvar _excluded = [\"name\"];\nvar VALIDATORS = [/*#__PURE__*/new FileSizeValidator(), /*#__PURE__*/new FilesLimitValidator(), /*#__PURE__*/new ImageDimensionsValidator()];\nfunction useFilePicker(props) {\n  var _props$accept = props.accept,\n    accept = _props$accept === void 0 ? '*' : _props$accept,\n    _props$multiple = props.multiple,\n    multiple = _props$multiple === void 0 ? true : _props$multiple,\n    _props$readAs = props.readAs,\n    readAs = _props$readAs === void 0 ? 'Text' : _props$readAs,\n    _props$readFilesConte = props.readFilesContent,\n    readFilesContent = _props$readFilesConte === void 0 ? true : _props$readFilesConte,\n    _props$validators = props.validators,\n    validators = _props$validators === void 0 ? [] : _props$validators,\n    onFilesSelected = props.onFilesSelected,\n    onFilesSuccessfulySelected = props.onFilesSuccessfulySelected,\n    onFilesRejected = props.onFilesRejected,\n    initializeWithCustomParameters = props.initializeWithCustomParameters;\n  var _useState = useState([]),\n    plainFiles = _useState[0],\n    setPlainFiles = _useState[1];\n  var _useState2 = useState([]),\n    filesContent = _useState2[0],\n    setFilesContent = _useState2[1];\n  var _useState3 = useState([]),\n    fileErrors = _useState3[0],\n    setFileErrors = _useState3[1];\n  var _useState4 = useState(false),\n    loading = _useState4[0],\n    setLoading = _useState4[1];\n  var clear = useCallback(function () {\n    setPlainFiles([]);\n    setFilesContent([]);\n    setFileErrors([]);\n  }, []);\n  var parseFile = function parseFile(file) {\n    return new Promise( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve, reject) {\n        var reader, readStrategy, addError;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              reader = new FileReader(); //availible reader methods: readAsText, readAsBinaryString, readAsArrayBuffer, readAsDataURL\n              readStrategy = reader[\"readAs\" + readAs];\n              readStrategy.call(reader, file);\n              addError = function addError(_ref2) {\n                var _ref2$name = _ref2.name,\n                  name = _ref2$name === void 0 ? file.name : _ref2$name,\n                  others = _objectWithoutPropertiesLoose(_ref2, _excluded);\n                reject(_extends({\n                  name: name,\n                  fileSizeToolarge: false,\n                  fileSizeTooSmall: false\n                }, others));\n              };\n              reader.onload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n                return _regeneratorRuntime().wrap(function _callee$(_context) {\n                  while (1) switch (_context.prev = _context.next) {\n                    case 0:\n                      return _context.abrupt(\"return\", Promise.all(VALIDATORS.concat(validators).map(function (validator) {\n                        return validator.validateAfterParsing(props, file, reader)[\"catch\"](function (err) {\n                          return Promise.reject(addError(err));\n                        });\n                      })).then(function () {\n                        return resolve(_extends({}, file, {\n                          content: reader.result,\n                          name: file.name,\n                          lastModified: file.lastModified\n                        }));\n                      })[\"catch\"](function () {}));\n                    case 1:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }, _callee);\n              }));\n              reader.onerror = function () {\n                addError({\n                  readerError: reader.error,\n                  plainFile: file\n                });\n              };\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  };\n  var openFileSelector = function openFileSelector() {\n    var fileExtensions = accept instanceof Array ? accept.join(',') : accept;\n    openFileDialog(fileExtensions, multiple, /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(evt) {\n        var inputElement, plainFileObjects, validations, files, fileErrors, filesContent;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              clear();\n              inputElement = evt.target;\n              plainFileObjects = inputElement.files ? Array.from(inputElement.files) : [];\n              setLoading(true);\n              _context3.next = 6;\n              return Promise.all(VALIDATORS.concat(validators).map(function (validator) {\n                return validator.validateBeforeParsing(props, plainFileObjects)[\"catch\"](function (err) {\n                  return err;\n                });\n              }));\n            case 6:\n              validations = _context3.sent.filter(Boolean);\n              setPlainFiles(plainFileObjects);\n              setFileErrors(validations);\n              if (!validations.length) {\n                _context3.next = 14;\n                break;\n              }\n              setLoading(false);\n              onFilesRejected == null ? void 0 : onFilesRejected({\n                errors: validations\n              });\n              onFilesSelected == null ? void 0 : onFilesSelected({\n                errors: validations\n              });\n              return _context3.abrupt(\"return\");\n            case 14:\n              if (readFilesContent) {\n                _context3.next = 18;\n                break;\n              }\n              setLoading(false);\n              onFilesSelected == null ? void 0 : onFilesSelected({\n                plainFiles: plainFileObjects,\n                filesContent: []\n              });\n              return _context3.abrupt(\"return\");\n            case 18:\n              _context3.next = 20;\n              return fromEvent(evt);\n            case 20:\n              files = _context3.sent;\n              fileErrors = [];\n              _context3.next = 24;\n              return Promise.all(files.map(function (file) {\n                return parseFile(file)[\"catch\"](function (fileError) {\n                  fileError.plainFile = file;\n                  fileErrors.push(fileError);\n                });\n              }));\n            case 24:\n              filesContent = _context3.sent;\n              setLoading(false);\n              if (!fileErrors.length) {\n                _context3.next = 33;\n                break;\n              }\n              setPlainFiles([]);\n              setFilesContent([]);\n              setFileErrors(function (errors) {\n                return [].concat(errors, fileErrors);\n              });\n              onFilesRejected == null ? void 0 : onFilesRejected({\n                errors: fileErrors\n              });\n              onFilesSelected == null ? void 0 : onFilesSelected({\n                errors: validations.concat(fileErrors)\n              });\n              return _context3.abrupt(\"return\");\n            case 33:\n              setFilesContent(filesContent);\n              setPlainFiles(plainFileObjects);\n              setFileErrors([]);\n              onFilesSuccessfulySelected == null ? void 0 : onFilesSuccessfulySelected({\n                filesContent: filesContent,\n                plainFiles: plainFileObjects\n              });\n              onFilesSelected == null ? void 0 : onFilesSelected({\n                plainFiles: plainFileObjects,\n                filesContent: filesContent\n              });\n            case 38:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      return function (_x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }(), initializeWithCustomParameters);\n  };\n  return [openFileSelector, {\n    filesContent: filesContent,\n    errors: fileErrors,\n    loading: loading,\n    plainFiles: plainFiles,\n    clear: clear\n  }];\n}\n\n/**\r\n * File limit validator has to be overriden to take into account the files that were previously selected\r\n * @param previousPlainFiles files that were previously selected\r\n * @returns a validator that checks if the amount of files selected previously and in the current batch is within the limits\r\n */\nvar persistentFileLimitValidator = function persistentFileLimitValidator(previousPlainFiles) {\n  return {\n    validateBeforeParsing: function validateBeforeParsing(config, plainFiles) {\n      var limitFilesConfig = config.limitFilesConfig;\n      var fileAmount = previousPlainFiles.length + plainFiles.length;\n      if (limitFilesConfig) {\n        if (limitFilesConfig.max && fileAmount > limitFilesConfig.max) {\n          return Promise.reject({\n            maxLimitExceeded: true\n          });\n        }\n        if (limitFilesConfig.min && fileAmount < limitFilesConfig.min) {\n          return Promise.reject({\n            minLimitNotReached: true\n          });\n        }\n      }\n      return Promise.resolve();\n    },\n    validateAfterParsing: function validateAfterParsing() {\n      return Promise.resolve();\n    }\n  };\n};\n\n/**\r\n * A version of useFilePicker hook that keeps selected files between selections. On top of that it allows to remove files from the selection.\r\n */\nfunction useImperativeFilePicker(props) {\n  var readFilesContent = props.readFilesContent,\n    _onFilesSelected = props.onFilesSelected,\n    _onFilesSuccessfulySelected = props.onFilesSuccessfulySelected;\n  var _useState = useState([]),\n    allPlainFiles = _useState[0],\n    setAllPlainFiles = _useState[1];\n  var _useState2 = useState([]),\n    allFilesContent = _useState2[0],\n    setAllFilesContent = _useState2[1];\n  var _useFilePicker = useFilePicker(_extends({}, props, {\n      validators: [persistentFileLimitValidator(allPlainFiles)].concat(props.validators || []),\n      onFilesSelected: function onFilesSelected(data) {\n        var _data$errors;\n        if (!_onFilesSelected) return;\n        if ((_data$errors = data.errors) != null && _data$errors.length) {\n          return _onFilesSelected(data);\n        }\n        // override the files property to return all files that were selected previously and in the current batch\n        _onFilesSelected({\n          errors: undefined,\n          plainFiles: [].concat(allPlainFiles, data.plainFiles || []),\n          filesContent: [].concat(allFilesContent, data.filesContent || [])\n        });\n      },\n      onFilesSuccessfulySelected: function onFilesSuccessfulySelected(data) {\n        setAllPlainFiles(function (previousPlainFiles) {\n          return previousPlainFiles.concat(data.plainFiles);\n        });\n        setAllFilesContent(function (previousFilesContent) {\n          return previousFilesContent.concat(data.filesContent);\n        });\n        if (!_onFilesSuccessfulySelected) return;\n        // override the files property to return all files that were selected previously and in the current batch\n        _onFilesSuccessfulySelected({\n          plainFiles: [].concat(allPlainFiles, data.plainFiles || []),\n          filesContent: [].concat(allFilesContent, data.filesContent || [])\n        });\n      }\n    })),\n    open = _useFilePicker[0],\n    _useFilePicker$ = _useFilePicker[1],\n    loading = _useFilePicker$.loading,\n    errors = _useFilePicker$.errors,\n    clear = _useFilePicker$.clear;\n  var clearPreviousFiles = useCallback(function () {\n    setAllPlainFiles([]);\n    if (readFilesContent) {\n      setAllFilesContent([]);\n    }\n  }, [readFilesContent]);\n  var clearAll = useCallback(function () {\n    clear();\n    clearPreviousFiles();\n  }, [clear, clearPreviousFiles]);\n  var removeFileByIndex = useCallback(function (index) {\n    setAllPlainFiles(function (previousPlainFiles) {\n      return [].concat(previousPlainFiles.slice(0, index), previousPlainFiles.slice(index + 1));\n    });\n    setAllFilesContent(function (previousFilesContent) {\n      return [].concat(previousFilesContent.slice(0, index), previousFilesContent.slice(index + 1));\n    });\n  }, []);\n  var removeFileByReference = useCallback(function (file) {\n    var index = allPlainFiles.findIndex(function (f) {\n      return f === file;\n    });\n    if (index === -1) return;\n    removeFileByIndex(index);\n  }, [removeFileByIndex, allPlainFiles]);\n  return [open, {\n    plainFiles: allPlainFiles,\n    filesContent: allFilesContent,\n    loading: loading,\n    errors: errors,\n    clear: clearAll,\n    removeFileByIndex: removeFileByIndex,\n    removeFileByReference: removeFileByReference\n  }];\n}\nexport { useFilePicker, useImperativeFilePicker };","map":{"version":3,"names":["BYTES_PER_MEGABYTE","FileSizeValidator","_proto","prototype","validateBeforeParsing","_validateBeforeParsing","_asyncToGenerator","_regeneratorRuntime","mark","_callee","config","plainFiles","minFileSize","maxFileSize","errors","wrap","_callee$","_context","prev","next","abrupt","Promise","resolve","map","file","getFileSizeError","fileSize","size","filter","error","length","reject","stop","_x","_x2","apply","arguments","validateAfterParsing","_validateAfterParsing","_callee2","_config","_file","_callee2$","_context2","_x3","_x4","_ref","minBytes","fileSizeTooSmall","maxBytes","fileSizeToolarge","FilesLimitValidator","limitFilesConfig","max","maxLimitExceeded","min","minLimitNotReached","openFileDialog","accept","multiple","callback","initializeWithCustomAttributes","inputElement","document","createElement","style","display","body","appendChild","type","addEventListener","arg","removeChild","dispatchEvent","MouseEvent","ImageDimensionsValidator","reader","readAs","imageSizeRestrictions","isImage","checkImageDimensions","result","fileType","startsWith","imgDataURL","img","Image","onload","maxHeight","maxWidth","minHeight","minWidth","width","height","_extends","imageHeightTooBig","imageHeightTooSmall","imageWidthTooBig","imageWidthTooSmall","Object","keys","onerror","imageNotLoaded","src","VALIDATORS","useFilePicker","props","_props$accept","_props$multiple","_props$readAs","_props$readFilesConte","readFilesContent","_props$validators","validators","onFilesSelected","onFilesSuccessfulySelected","onFilesRejected","initializeWithCustomParameters","_useState","useState","setPlainFiles","_useState2","filesContent","setFilesContent","_useState3","fileErrors","setFileErrors","_useState4","loading","setLoading","clear","useCallback","parseFile","readStrategy","addError","FileReader","call","_ref2","_ref2$name","name","others","_objectWithoutPropertiesLoose","_excluded","all","concat","validator","err","then","content","lastModified","readerError","plainFile","openFileSelector","fileExtensions","Array","join","_ref4","_callee3","evt","plainFileObjects","validations","files","_callee3$","_context3","target","from","sent","Boolean","fromEvent","fileError","push","persistentFileLimitValidator","previousPlainFiles","fileAmount","useImperativeFilePicker","_onFilesSelected","_onFilesSuccessfulySelected","allPlainFiles","setAllPlainFiles","allFilesContent","setAllFilesContent","_useFilePicker","data","_data$errors","undefined","previousFilesContent","open","_useFilePicker$","clearPreviousFiles","clearAll","removeFileByIndex","index","slice","removeFileByReference","findIndex","f"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/constants/bytesPerMegabyte.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/validators/fileSizeValidator/index.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/validators/filesLimitValidator/index.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/helpers/openFileDialog.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/validators/imageDimensionsValidator/index.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/useFilePicker.tsx","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/validators/persistentFilesLimitValidator/index.ts","/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/use-file-picker/src/useImperativeFilePicker.tsx"],"sourcesContent":["export const BYTES_PER_MEGABYTE = 1000000;\n","import { FileWithPath } from 'file-selector';\nimport { BYTES_PER_MEGABYTE } from '../../constants/bytesPerMegabyte';\nimport { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class FileSizeValidator implements Validator {\n  async validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { minFileSize, maxFileSize } = config;\n\n    if (!minFileSize && !maxFileSize) {\n      return Promise.resolve();\n    }\n\n    const errors = plainFiles\n      .map(file => getFileSizeError({ minFileSize, maxFileSize, fileSize: file.size }))\n      .filter(error => !!error);\n\n    return errors.length > 0 ? Promise.reject(errors[0]) : Promise.resolve();\n  }\n  async validateAfterParsing(_config: UseFilePickerConfig, _file: FileWithPath): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nconst getFileSizeError = ({\n  fileSize,\n  maxFileSize,\n  minFileSize,\n}: {\n  minFileSize: number | undefined;\n  maxFileSize: number | undefined;\n  fileSize: number;\n}) => {\n  if (minFileSize) {\n    const minBytes = minFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize < minBytes) {\n      return { fileSizeTooSmall: true };\n    }\n  }\n  if (maxFileSize) {\n    const maxBytes = maxFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize > maxBytes) {\n      return { fileSizeToolarge: true };\n    }\n  }\n};\n","import { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class FilesLimitValidator implements Validator {\n  validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { limitFilesConfig } = config;\n    if (limitFilesConfig) {\n      if (limitFilesConfig.max && plainFiles.length > limitFilesConfig.max) {\n        return Promise.reject({ maxLimitExceeded: true });\n      }\n\n      if (limitFilesConfig.min && plainFiles.length < limitFilesConfig.min) {\n        return Promise.reject({ minLimitNotReached: true });\n      }\n    }\n    return Promise.resolve();\n  }\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n","export function openFileDialog(\n  accept: string,\n  multiple: boolean,\n  callback: (arg: Event) => void,\n  initializeWithCustomAttributes?: (arg: HTMLInputElement) => void\n): void {\n  // this function must be called from a user\n  // activation event (ie an onclick event)\n\n  // Create an input element\n  var inputElement = document.createElement('input');\n  // Hide element and append to body (required to run on iOS safari)\n  inputElement.style.display = 'none';\n  document.body.appendChild(inputElement);\n  // Set its type to file\n  inputElement.type = 'file';\n  // Set accept to the file types you want the user to select.\n  // Include both the file extension and the mime type\n  // if accept is \"*\" then dont set the accept attribute\n  if (accept !== '*') inputElement.accept = accept;\n  // Accept multiple files\n  inputElement.multiple = multiple;\n  // set onchange event to call callback when user has selected file\n  //inputElement.addEventListener('change', callback);\n  inputElement.addEventListener('change', arg => {\n    callback(arg);\n    // remove element\n    document.body.removeChild(inputElement);\n  });\n\n  if (initializeWithCustomAttributes) {\n    initializeWithCustomAttributes(inputElement);\n  }\n  // dispatch a click event to open the file dialog\n  inputElement.dispatchEvent(new MouseEvent('click'));\n}\n","import { FileWithPath } from 'file-selector';\nimport { ImageDimensionError, ImageDims, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class ImageDimensionsValidator implements Validator {\n  validateBeforeParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n  validateAfterParsing(config: UseFilePickerConfig, file: FileWithPath, reader: FileReader): Promise<void> {\n    const { readAs, imageSizeRestrictions } = config;\n    if (readAs === 'DataURL' && imageSizeRestrictions && isImage(file.type)) {\n      return checkImageDimensions(reader.result as string, imageSizeRestrictions);\n    }\n    return Promise.resolve();\n  }\n}\n\nconst isImage = (fileType: string) => fileType.startsWith('image');\n\nconst checkImageDimensions = (imgDataURL: string, imageSizeRestrictions: ImageDims) =>\n  new Promise<void>((resolve, reject) => {\n    const img = new Image();\n    img.onload = function () {\n      const { maxHeight, maxWidth, minHeight, minWidth } = imageSizeRestrictions;\n      const { width, height } = this as unknown as typeof img;\n      let errors: ImageDimensionError = {};\n      if (maxHeight && maxHeight < height) errors = { ...errors, imageHeightTooBig: true };\n      if (minHeight && minHeight > height) errors = { ...errors, imageHeightTooSmall: true };\n      if (maxWidth && maxWidth < width) errors = { ...errors, imageWidthTooBig: true };\n      if (minWidth && minWidth > width) errors = { ...errors, imageWidthTooSmall: true };\n      Object.keys(errors).length ? reject(errors) : resolve();\n    };\n    img.onerror = function () {\n      reject({ imageNotLoaded: true } as ImageDimensionError);\n    };\n    img.src = imgDataURL;\n  });\n","import { useState, useCallback } from 'react';\nimport { fromEvent, FileWithPath } from 'file-selector';\nimport { UseFilePickerConfig, FileContent, FilePickerReturnTypes, FileError, ReaderMethod } from './interfaces';\nimport FileSizeValidator from './validators/fileSizeValidator';\nimport FilesLimitValidator from './validators/filesLimitValidator';\nimport { Validator } from './validators/validatorInterface';\nimport { openFileDialog } from './helpers/openFileDialog';\nimport ImageDimensionsValidator from './validators/imageDimensionsValidator';\n\nconst VALIDATORS: Validator[] = [new FileSizeValidator(), new FilesLimitValidator(), new ImageDimensionsValidator()];\n\nfunction useFilePicker(props: UseFilePickerConfig): FilePickerReturnTypes {\n  const {\n    accept = '*',\n    multiple = true,\n    readAs = 'Text',\n    readFilesContent = true,\n    validators = [],\n    onFilesSelected,\n    onFilesSuccessfulySelected,\n    onFilesRejected,\n    initializeWithCustomParameters,\n  } = props;\n  const [plainFiles, setPlainFiles] = useState<File[]>([]);\n  const [filesContent, setFilesContent] = useState<FileContent[]>([]);\n  const [fileErrors, setFileErrors] = useState<FileError[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const clear: () => void = useCallback(() => {\n    setPlainFiles([]);\n    setFilesContent([]);\n    setFileErrors([]);\n  }, []);\n\n  const parseFile = (file: FileWithPath) =>\n    new Promise<FileContent>(\n      async (resolve: (fileContent: FileContent) => void, reject: (reason: FileError) => void) => {\n        const reader = new FileReader();\n\n        //availible reader methods: readAsText, readAsBinaryString, readAsArrayBuffer, readAsDataURL\n        const readStrategy = reader[`readAs${readAs}` as ReaderMethod] as typeof reader.readAsText;\n        readStrategy.call(reader, file);\n\n        const addError = ({ name = file.name, ...others }: FileError) => {\n          reject({ name, fileSizeToolarge: false, fileSizeTooSmall: false, ...others });\n        };\n\n        reader.onload = async () =>\n          Promise.all(\n            VALIDATORS.concat(validators).map(validator =>\n              validator.validateAfterParsing(props, file, reader).catch(err => Promise.reject(addError(err)))\n            )\n          )\n            .then(() =>\n              resolve({\n                ...file,\n                content: reader.result as string,\n                name: file.name,\n                lastModified: file.lastModified,\n              } as FileContent)\n            )\n            .catch(() => {});\n\n        reader.onerror = () => {\n          addError({ readerError: reader.error, plainFile: file });\n        };\n      }\n    );\n\n  const openFileSelector = () => {\n    const fileExtensions = accept instanceof Array ? accept.join(',') : accept;\n    openFileDialog(\n      fileExtensions,\n      multiple,\n      async evt => {\n        clear();\n        const inputElement = evt.target as HTMLInputElement;\n        const plainFileObjects = inputElement.files ? Array.from(inputElement.files) : [];\n\n        setLoading(true);\n\n        const validations = (\n          (await Promise.all(\n            VALIDATORS.concat(validators).map(validator =>\n              validator.validateBeforeParsing(props, plainFileObjects).catch((err: FileError) => err)\n            )\n          )) as FileError[]\n        ).filter(Boolean);\n\n        setPlainFiles(plainFileObjects);\n        setFileErrors(validations);\n        if (validations.length) {\n          setLoading(false);\n          onFilesRejected?.({ errors: validations });\n          onFilesSelected?.({ errors: validations });\n          return;\n        }\n\n        if (!readFilesContent) {\n          setLoading(false);\n          onFilesSelected?.({ plainFiles: plainFileObjects, filesContent: [] });\n          return;\n        }\n\n        const files = (await fromEvent(evt)) as FileWithPath[];\n\n        const fileErrors: FileError[] = [];\n        const filesContent = (await Promise.all(\n          files.map(file =>\n            parseFile(file).catch(fileError => {\n              fileError.plainFile = file;\n              fileErrors.push(fileError);\n            })\n          )\n        )) as FileContent[];\n        setLoading(false);\n\n        if (fileErrors.length) {\n          setPlainFiles([]);\n          setFilesContent([]);\n          setFileErrors(errors => [...errors, ...fileErrors]);\n          onFilesRejected?.({ errors: fileErrors });\n          onFilesSelected?.({\n            errors: validations.concat(fileErrors),\n          });\n          return;\n        }\n\n        setFilesContent(filesContent);\n        setPlainFiles(plainFileObjects);\n        setFileErrors([]);\n        onFilesSuccessfulySelected?.({ filesContent, plainFiles: plainFileObjects });\n        onFilesSelected?.({\n          plainFiles: plainFileObjects,\n          filesContent,\n        });\n      },\n      initializeWithCustomParameters\n    );\n  };\n\n  return [openFileSelector, { filesContent, errors: fileErrors, loading, plainFiles, clear }];\n}\n\nexport default useFilePicker;\n","import { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\n/**\n * File limit validator has to be overriden to take into account the files that were previously selected\n * @param previousPlainFiles files that were previously selected\n * @returns a validator that checks if the amount of files selected previously and in the current batch is within the limits\n */\nconst persistentFileLimitValidator: (previousPlainFiles: File[]) => Validator = previousPlainFiles => ({\n  validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { limitFilesConfig } = config;\n    const fileAmount = previousPlainFiles.length + plainFiles.length;\n    if (limitFilesConfig) {\n      if (limitFilesConfig.max && fileAmount > limitFilesConfig.max) {\n        return Promise.reject({ maxLimitExceeded: true });\n      }\n\n      if (limitFilesConfig.min && fileAmount < limitFilesConfig.min) {\n        return Promise.reject({ minLimitNotReached: true });\n      }\n    }\n    return Promise.resolve();\n  },\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  },\n});\n\nexport default persistentFileLimitValidator;\n","import { useCallback, useState } from 'react';\nimport { FileContent, ImperativeFilePickerReturnTypes, UseFilePickerConfig } from './interfaces';\nimport useFilePicker from './useFilePicker';\nimport persistentFileLimitValidator from './validators/persistentFilesLimitValidator';\n\n/**\n * A version of useFilePicker hook that keeps selected files between selections. On top of that it allows to remove files from the selection.\n */\nfunction useImperativeFilePicker(props: UseFilePickerConfig): ImperativeFilePickerReturnTypes {\n  const { readFilesContent, onFilesSelected, onFilesSuccessfulySelected } = props;\n\n  const [allPlainFiles, setAllPlainFiles] = useState<File[]>([]);\n  const [allFilesContent, setAllFilesContent] = useState<FileContent[]>([]);\n\n  const [open, { loading, errors, clear }] = useFilePicker({\n    ...props,\n    validators: [persistentFileLimitValidator(allPlainFiles), ...(props.validators || [])],\n    onFilesSelected: data => {\n      if (!onFilesSelected) return;\n      if (data.errors?.length) {\n        return onFilesSelected(data);\n      }\n      // override the files property to return all files that were selected previously and in the current batch\n      onFilesSelected({\n        errors: undefined,\n        plainFiles: [...allPlainFiles, ...(data.plainFiles || [])],\n        filesContent: [...allFilesContent, ...(data.filesContent || [])],\n      });\n    },\n    onFilesSuccessfulySelected: data => {\n      setAllPlainFiles(previousPlainFiles => previousPlainFiles.concat(data.plainFiles));\n      setAllFilesContent(previousFilesContent => previousFilesContent.concat(data.filesContent));\n\n      if (!onFilesSuccessfulySelected) return;\n      // override the files property to return all files that were selected previously and in the current batch\n      onFilesSuccessfulySelected({\n        plainFiles: [...allPlainFiles, ...(data.plainFiles || [])],\n        filesContent: [...allFilesContent, ...(data.filesContent || [])],\n      });\n    },\n  });\n\n  const clearPreviousFiles = useCallback(() => {\n    setAllPlainFiles([]);\n    if (readFilesContent) {\n      setAllFilesContent([]);\n    }\n  }, [readFilesContent]);\n\n  const clearAll = useCallback(() => {\n    clear();\n    clearPreviousFiles();\n  }, [clear, clearPreviousFiles]);\n\n  const removeFileByIndex = useCallback((index: number) => {\n    setAllPlainFiles(previousPlainFiles => [\n      ...previousPlainFiles.slice(0, index),\n      ...previousPlainFiles.slice(index + 1),\n    ]);\n    setAllFilesContent(previousFilesContent => [\n      ...previousFilesContent.slice(0, index),\n      ...previousFilesContent.slice(index + 1),\n    ]);\n  }, []);\n\n  const removeFileByReference = useCallback(\n    (file: File) => {\n      const index = allPlainFiles.findIndex(f => f === file);\n      if (index === -1) return;\n      removeFileByIndex(index);\n    },\n    [removeFileByIndex, allPlainFiles]\n  );\n\n  return [\n    open,\n    {\n      plainFiles: allPlainFiles,\n      filesContent: allFilesContent,\n      loading,\n      errors,\n      clear: clearAll,\n      removeFileByIndex,\n      removeFileByReference,\n    },\n  ];\n}\n\nexport default useImperativeFilePicker;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}