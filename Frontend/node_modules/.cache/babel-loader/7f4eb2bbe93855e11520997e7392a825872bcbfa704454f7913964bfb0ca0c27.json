{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid() {\n    let _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)`await ` : codegen_1.nil;\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\nfunction checkAsyncKeyword(_ref, def) {\n  let {\n    schemaEnv\n  } = _ref;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\nfunction validSchemaType(schema, schemaType) {\n  let allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  let {\n    schema,\n    opts,\n    self,\n    errSchemaPath\n  } = _ref2;\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  const deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"names":["codegen_1","require","names_1","code_1","errors_1","macroKeywordCode","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","nil","errSchemaPath","topSchemaRef","compositeRule","pass","error","exports","funcKeywordCode","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","_a","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","_","e","assign","if","ValidationError","throw","validateErrs","_await","arguments","length","undefined","passCxt","passContext","default","this","passSchema","callValidateCode","not","data","parentData","parentDataProperty","errs","vErrors","extendErrors","_ref","schemaEnv","$async","Error","result","scopeValue","ref","code","stringify","validSchemaType","schemaType","allowUndefined","some","st","Array","isArray","validateKeywordUsage","_ref2","includes","deps","dependencies","kwd","Object","prototype","hasOwnProperty","join","msg","errorsText","logger"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/compile/validate/keyword.ts"],"sourcesContent":["import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}