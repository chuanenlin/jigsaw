{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = require(\"../compile/codegen\");\nconst util_1 = require(\"../compile/util\");\nconst names_1 = require(\"../compile/names\");\nconst util_2 = require(\"../compile/util\");\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: (0, codegen_1._)`${prop}`\n    }, true);\n    cxt.error();\n  });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: (0, codegen_1._)`Object.prototype.hasOwnProperty`\n  });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n  return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n  return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n  return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n  const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n  return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._)`new RegExp`;\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  const {\n    regExp\n  } = opts.code;\n  const rx = regExp(pattern, u);\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: (0, codegen_1._)`${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`\n  });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if((0, codegen_1.not)(valid), notValid);\n    });\n  }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n    // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n    if (!merged) gen.if((0, codegen_1.not)(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;","map":{"version":3,"names":["codegen_1","require","util_1","names_1","util_2","checkReportMissingProp","cxt","prop","gen","data","it","if","noPropertyInData","opts","ownProperties","setParams","missingProperty","_","error","exports","checkMissingProp","_ref","properties","missing","or","map","and","reportMissingProp","hasPropFunc","scopeValue","ref","Object","prototype","hasOwnProperty","code","isOwnProperty","property","propertyInData","cond","getProperty","not","allSchemaProperties","schemaMap","keys","filter","p","schemaProperties","alwaysValidSchema","callValidateCode","_ref2","func","context","passSchema","schemaCode","topSchemaRef","schemaPath","errorPath","dataAndSchema","valCxt","default","instancePath","strConcat","parentData","parentDataProperty","rootData","dynamicRef","push","dynamicAnchors","args","object","nil","newRegExp","usePattern","_ref3","pattern","u","unicodeRegExp","regExp","rx","key","toString","useFunc","validateArray","keyword","valid","name","allErrors","validArr","let","validateItems","assign","var","break","notValid","len","const","forRange","i","subschema","dataProp","dataPropType","Type","Num","validateUnion","schema","Array","isArray","Error","alwaysValid","some","sch","unevaluated","schValid","block","forEach","_sch","schCxt","schemaProp","compositeRule","merged","mergeValidEvaluated","result","reset"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}