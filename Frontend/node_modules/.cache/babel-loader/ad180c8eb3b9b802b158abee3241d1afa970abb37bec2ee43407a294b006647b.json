{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1.str)`must match \"${params.ifClause}\" schema`;\n  },\n  params: _ref2 => {\n    let {\n      params\n    } = _ref2;\n    return (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`;\n  }\n};\nconst def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      it\n    } = cxt;\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n    const hasThen = hasSchema(it, \"then\");\n    const hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    const valid = gen.let(\"valid\", true);\n    const schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n    cxt.pass(valid, () => cxt.error(true));\n    function validateIf() {\n      const schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n    function validateClause(keyword, ifClause) {\n      return () => {\n        const schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n};\nfunction hasSchema(it, keyword) {\n  const schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","error","message","_ref","params","str","ifClause","_ref2","_","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","checkStrictMode","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","not","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","alwaysValidSchema","exports","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/applicator/if.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}