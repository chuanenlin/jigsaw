{"ast":null,"code":"const escapeMatch = /[.[\\]]/;\nconst escapeRegex = /\"/g;\n/** @internal */\nfunction escape(string) {\n  return string === '' || escapeMatch.test(string) ? `[\"${string.replace(escapeRegex, '\\\\\"')}\"]` : string;\n}\n/** @internal */\nfunction escapeToJoin(string, index) {\n  const escaped = escape(string);\n  return escaped === string ? index ? `.${string}` : string : escaped;\n}\nconst unescapeMatch = /^\\[\"(.*)\"]$/;\nconst unescapeRegex = /\\\\\"/g;\n/** @internal */\nfunction unescape(string) {\n  const match = unescapeMatch.exec(string);\n  return match ? match[1].replace(unescapeRegex, '\"') : string;\n}\n// This regular expression splits the string into three parts:\n//   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n//            front (hence prefix). It covers most standard usecases.\n//   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n//               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n//   `rest` is anything following the subscript. The leading dot (`.`)\n//          is stripped (`.a` -> `a`) if there is one. It is empty if\n//          `subscript` is empty.\n//\n// All three parts can be empty!\nconst nameRegex = /^([^.[\\]]*(?:\\.[^.[\\]]+)*)(?:\\.?(\\[\"(?:(?:[^\"]|\\\\\")*?[^\\\\])?\"])\\.?(.*))?$/;\n// eslint-disable-next-line complexity -- The complexity of it _is_ high.\nfunction joinNameImpl() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n  // If the first argument is `null`, then we return an escaped array of parts.\n  // Otherwise, an escaped string is returned. As we may modify `parts` later,\n  // this has to be checked now.\n  const returnAsParts = parts[0] === null;\n  // Result parts (not escaped).\n  const name = [];\n  // This cannot be transformed into a `.forEach` loop and the length of it\n  // can not be memoized, as we modify `parts` as we go for performance reasons.\n  for (let index = 0; index !== parts.length; ++index) {\n    const part = parts[index];\n    // All falsy values except `0` are ignored.\n    if (part || part === 0) {\n      if (typeof part === 'string') {\n        // Strings are matched against the regular expression that split it into\n        // three parts (all can be empty):\n        //   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n        //            front (hence prefix). It covers most standard usecases.\n        //   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n        //               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n        //   `rest` is anything following the subscript. The leading dot (`.`)\n        //          is stripped (`.a` -> `a`) if there is one. It is empty if\n        //          `subscript` is empty.\n        const match = nameRegex.exec(part);\n        if (match) {\n          const [, prefix, subscript, rest] = match;\n          if (prefix) {\n            // We could always `.split` the `prefix`, but it results in a severe\n            // performance hit.\n            if (prefix.includes('.')) {\n              name.push(...prefix.split('.'));\n            } else {\n              name.push(prefix);\n            }\n          }\n          if (subscript) {\n            // We could adjust the `nameRegex` to skip brackets and `unescape`\n            // to skip this check, but then every other call (e.g., a one in the\n            // bridge) would have to know that. The performance is not affected\n            // much by it anyway.\n            name.push(unescape(subscript));\n            // The `rest` is inlined in place as it is a single string.\n            if (rest) {\n              parts[index--] = rest;\n            }\n          }\n        } else {\n          // If a string is not matching the pattern, we leave it as it is. We\n          // may want to raise a warning here as it should not happen. Most\n          // likely it is something that should have been escaped (e.g., `[`).\n          name.push(part);\n        }\n      } else if (Array.isArray(part)) {\n        // Arrays are flattened in place but only if needed, i.e., they are not\n        // empty. We calculate the length of the overlapping parts to reuse the\n        // `parts` array as much as possible:\n        // [[], ...]              -> [[], ...]       // No change.\n        // [['a'], ...]           -> ['a', ...]      // Inline in place.\n        // [['a', 'b'], ...]      -> ['a', 'b', ...] // Inline with extension.\n        // ['a', ['b'], ...]      -> ['a', 'b', ...] // Inline in place.\n        // ['a', ['b', 'c'], ...] -> ['b', 'c', ...] // Inline with overlap.\n        if (part.length) {\n          const length = Math.min(index + 1, part.length);\n          index -= length;\n          parts.splice(index + 1, length, ...part);\n        }\n      } else {\n        // Other values -- most likely numbers and `true` -- are stringified.\n        name.push('' + part);\n      }\n    }\n  }\n  // We cannot escape the parts earlier as `escapeToJoin` depends on the index.\n  return returnAsParts ? name.map(escape) : name.map(escapeToJoin).join('');\n}\nexport const joinName = Object.assign(joinNameImpl, {\n  escape,\n  unescape\n});","map":{"version":3,"names":["escapeMatch","escapeRegex","escape","string","test","replace","escapeToJoin","index","escaped","unescapeMatch","unescapeRegex","unescape","match","exec","nameRegex","joinNameImpl","_len","arguments","length","parts","Array","_key","returnAsParts","name","part","prefix","subscript","rest","includes","push","split","isArray","Math","min","splice","map","join","joinName","Object","assign"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/uniforms/esm/joinName.js"],"sourcesContent":["const escapeMatch = /[.[\\]]/;\nconst escapeRegex = /\"/g;\n/** @internal */\nfunction escape(string) {\n    return string === '' || escapeMatch.test(string)\n        ? `[\"${string.replace(escapeRegex, '\\\\\"')}\"]`\n        : string;\n}\n/** @internal */\nfunction escapeToJoin(string, index) {\n    const escaped = escape(string);\n    return escaped === string ? (index ? `.${string}` : string) : escaped;\n}\nconst unescapeMatch = /^\\[\"(.*)\"]$/;\nconst unescapeRegex = /\\\\\"/g;\n/** @internal */\nfunction unescape(string) {\n    const match = unescapeMatch.exec(string);\n    return match ? match[1].replace(unescapeRegex, '\"') : string;\n}\n// This regular expression splits the string into three parts:\n//   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n//            front (hence prefix). It covers most standard usecases.\n//   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n//               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n//   `rest` is anything following the subscript. The leading dot (`.`)\n//          is stripped (`.a` -> `a`) if there is one. It is empty if\n//          `subscript` is empty.\n//\n// All three parts can be empty!\nconst nameRegex = /^([^.[\\]]*(?:\\.[^.[\\]]+)*)(?:\\.?(\\[\"(?:(?:[^\"]|\\\\\")*?[^\\\\])?\"])\\.?(.*))?$/;\n// eslint-disable-next-line complexity -- The complexity of it _is_ high.\nfunction joinNameImpl(...parts) {\n    // If the first argument is `null`, then we return an escaped array of parts.\n    // Otherwise, an escaped string is returned. As we may modify `parts` later,\n    // this has to be checked now.\n    const returnAsParts = parts[0] === null;\n    // Result parts (not escaped).\n    const name = [];\n    // This cannot be transformed into a `.forEach` loop and the length of it\n    // can not be memoized, as we modify `parts` as we go for performance reasons.\n    for (let index = 0; index !== parts.length; ++index) {\n        const part = parts[index];\n        // All falsy values except `0` are ignored.\n        if (part || part === 0) {\n            if (typeof part === 'string') {\n                // Strings are matched against the regular expression that split it into\n                // three parts (all can be empty):\n                //   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n                //            front (hence prefix). It covers most standard usecases.\n                //   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n                //               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n                //   `rest` is anything following the subscript. The leading dot (`.`)\n                //          is stripped (`.a` -> `a`) if there is one. It is empty if\n                //          `subscript` is empty.\n                const match = nameRegex.exec(part);\n                if (match) {\n                    const [, prefix, subscript, rest] = match;\n                    if (prefix) {\n                        // We could always `.split` the `prefix`, but it results in a severe\n                        // performance hit.\n                        if (prefix.includes('.')) {\n                            name.push(...prefix.split('.'));\n                        }\n                        else {\n                            name.push(prefix);\n                        }\n                    }\n                    if (subscript) {\n                        // We could adjust the `nameRegex` to skip brackets and `unescape`\n                        // to skip this check, but then every other call (e.g., a one in the\n                        // bridge) would have to know that. The performance is not affected\n                        // much by it anyway.\n                        name.push(unescape(subscript));\n                        // The `rest` is inlined in place as it is a single string.\n                        if (rest) {\n                            parts[index--] = rest;\n                        }\n                    }\n                }\n                else {\n                    // If a string is not matching the pattern, we leave it as it is. We\n                    // may want to raise a warning here as it should not happen. Most\n                    // likely it is something that should have been escaped (e.g., `[`).\n                    name.push(part);\n                }\n            }\n            else if (Array.isArray(part)) {\n                // Arrays are flattened in place but only if needed, i.e., they are not\n                // empty. We calculate the length of the overlapping parts to reuse the\n                // `parts` array as much as possible:\n                // [[], ...]              -> [[], ...]       // No change.\n                // [['a'], ...]           -> ['a', ...]      // Inline in place.\n                // [['a', 'b'], ...]      -> ['a', 'b', ...] // Inline with extension.\n                // ['a', ['b'], ...]      -> ['a', 'b', ...] // Inline in place.\n                // ['a', ['b', 'c'], ...] -> ['b', 'c', ...] // Inline with overlap.\n                if (part.length) {\n                    const length = Math.min(index + 1, part.length);\n                    index -= length;\n                    parts.splice(index + 1, length, ...part);\n                }\n            }\n            else {\n                // Other values -- most likely numbers and `true` -- are stringified.\n                name.push('' + part);\n            }\n        }\n    }\n    // We cannot escape the parts earlier as `escapeToJoin` depends on the index.\n    return returnAsParts ? name.map(escape) : name.map(escapeToJoin).join('');\n}\nexport const joinName = Object.assign(joinNameImpl, { escape, unescape });\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}