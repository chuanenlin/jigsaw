{"ast":null,"code":"import * as Blockly from 'blockly';\nexport class ChildBasedDragger extends Blockly.BlockDragger {\n  constructor(block, workspace) {\n    super(block, workspace);\n    this.originalDraggingBlock = void 0;\n    this.childDraggedConnectionManager_ = void 0;\n    /* same as parent's dragTarget but can't use the one from parent because it's private */\n    this.myDragTarget_ = null;\n    this.originalDraggingBlock = block;\n    this.draggingBlock_ = this.getRoot(block);\n\n    /** Object that keeps track of connections on dragged blocks. */\n    this.draggedConnectionManager_ = new Blockly.InsertionMarkerManager(this.getRoot(this.draggingBlock_));\n    this.childDraggedConnectionManager_ = new Blockly.InsertionMarkerManager(this.originalDraggingBlock);\n\n    /**\n     * The location of the top left corner of the dragging block at the\n     * beginning of the drag in workspace coordinates.\n     */\n    this.startXY_ = this.getRoot(this.draggingBlock_).getRelativeToSurfaceXY();\n  }\n  dispose() {\n    super.dispose();\n    if (this.childDraggedConnectionManager_) {\n      this.childDraggedConnectionManager_.dispose();\n    }\n  }\n  shouldDisconnect_(healStack) {\n    return !!(this.originalDraggingBlock.getChildren(true).length > 0 || healStack && this.originalDraggingBlock.previousConnection && this.originalDraggingBlock.previousConnection.targetBlock());\n  }\n\n  /**\n   * Disconnects the block and moves it to a new location.\n   *\n   * @param healStack Whether or not to heal the stack after disconnecting.\n   * @param currentDragDeltaXY How far the pointer has moved from the position\n   *     at mouse down, in pixel units.\n   */\n  disconnectBlock_(healStack, currentDragDeltaXY) {\n    const childBlocks = this.originalDraggingBlock.getChildren(true);\n    childBlocks.forEach(childBlock => childBlock.unplug(healStack));\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    const newLoc = Blockly.utils.Coordinate.sum(this.startXY_, delta);\n    this.draggingBlock_.translate(newLoc.x, newLoc.y);\n    Blockly.blockAnimations.disconnectUiEffect(this.draggingBlock_);\n    this.draggedConnectionManager_.updateAvailableConnections();\n    this.childDraggedConnectionManager_.updateAvailableConnections();\n  }\n  drag(e, currentDragDeltaXY) {\n    var _this$workspace_$tras;\n    super.drag(e, currentDragDeltaXY);\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);\n    const oldDragTarget = this.myDragTarget_;\n    this.myDragTarget_ = this.workspace_.getDragTarget(e);\n    this.childDraggedConnectionManager_.update(delta, this.myDragTarget_);\n    const oldWouldDeleteBlock2 = (_this$workspace_$tras = this.workspace_.trashcan) === null || _this$workspace_$tras === void 0 ? void 0 : _this$workspace_$tras.wouldDelete(this.draggingBlock_, false);\n    this.wouldDeleteBlock_ = this.childDraggedConnectionManager_.wouldDeleteBlock;\n    if (oldWouldDeleteBlock2 !== this.wouldDeleteBlock_) {\n      // Prevent unnecessary add/remove class calls.\n      this.updateCursorDuringBlockDrag_();\n    }\n\n    // Call drag enter/exit/over after wouldDeleteBlock is called in\n    // InsertionMarkerManager.update.\n    if (this.myDragTarget_ !== oldDragTarget) {\n      oldDragTarget && oldDragTarget.onDragExit(this.originalDraggingBlock);\n      this.myDragTarget_ && this.myDragTarget_.onDragEnter(this.originalDraggingBlock);\n    }\n    this.myDragTarget_ && this.myDragTarget_.onDragOver(this.originalDraggingBlock);\n  }\n  endDrag(e, currentDragDeltaXY) {\n    super.endDrag(e, currentDragDeltaXY);\n    if (this.myDragTarget_) {\n      var _this$workspace_$tras2;\n      this.myDragTarget_.onDrop(this.originalDraggingBlock);\n      if ((_this$workspace_$tras2 = this.workspace_.trashcan) !== null && _this$workspace_$tras2 !== void 0 && _this$workspace_$tras2.wouldDelete(this.draggingBlock_, false)) {\n        this.draggingBlock_.dispose(true, true);\n      }\n    }\n  }\n  updateBlockAfterMove_() {\n    this.fireMoveEvent_();\n    const oldRoot = this.draggingBlock_;\n    const oldRootLoc = oldRoot.getRelativeToSurfaceXY();\n    const dragging = this.originalDraggingBlock;\n    const draggingLoc = dragging.getRelativeToSurfaceXY();\n    let intersectionMarker;\n    let intersectionMarkerLoc;\n    if (this.draggedConnectionManager_.wouldConnectBlock()) {\n      intersectionMarker = this.draggedConnectionManager_.getInsertionMarkers()[0];\n      intersectionMarkerLoc = intersectionMarker.getRelativeToSurfaceXY();\n\n      // Applying connections also rerenders the relevant blocks.\n      this.draggedConnectionManager_.applyConnections();\n    } else if (this.childDraggedConnectionManager_.wouldConnectBlock()) {\n      intersectionMarker = this.childDraggedConnectionManager_.getInsertionMarkers()[0];\n      intersectionMarkerLoc = intersectionMarker.getRelativeToSurfaceXY();\n      this.childDraggedConnectionManager_.applyConnections();\n    } else {\n      this.draggingBlock_.queueRender();\n    }\n    this.draggingBlock_.scheduleSnapAndBump();\n    if (intersectionMarkerLoc) {\n      const root = this.getRoot(this.draggingBlock_);\n      const isSuperior = oldRoot.id === root.id;\n      if (isSuperior) {\n        const delta = Blockly.utils.Coordinate.difference(intersectionMarkerLoc, draggingLoc);\n        root.moveBy(delta.x, delta.y);\n      } else {\n        const delta = Blockly.utils.Coordinate.difference(oldRootLoc, intersectionMarkerLoc);\n        root.moveBy(delta.x, delta.y);\n      }\n    }\n  }\n  getInsertionMarkers() {\n    const res = super.getInsertionMarkers();\n    if (this.childDraggedConnectionManager_ && this.childDraggedConnectionManager_.getInsertionMarkers) {\n      return this.childDraggedConnectionManager_.getInsertionMarkers();\n    }\n    return res;\n  }\n  getRoot(block) {\n    let parent = block.getParent();\n    while (parent) {\n      block = parent;\n      parent = block.getParent();\n    }\n    return block;\n  }\n}","map":{"version":3,"names":["Blockly","ChildBasedDragger","BlockDragger","constructor","block","workspace","originalDraggingBlock","childDraggedConnectionManager_","myDragTarget_","draggingBlock_","getRoot","draggedConnectionManager_","InsertionMarkerManager","startXY_","getRelativeToSurfaceXY","dispose","shouldDisconnect_","healStack","getChildren","length","previousConnection","targetBlock","disconnectBlock_","currentDragDeltaXY","childBlocks","forEach","childBlock","unplug","delta","pixelsToWorkspaceUnits_","newLoc","utils","Coordinate","sum","translate","x","y","blockAnimations","disconnectUiEffect","updateAvailableConnections","drag","e","_this$workspace_$tras","oldDragTarget","workspace_","getDragTarget","update","oldWouldDeleteBlock2","trashcan","wouldDelete","wouldDeleteBlock_","wouldDeleteBlock","updateCursorDuringBlockDrag_","onDragExit","onDragEnter","onDragOver","endDrag","_this$workspace_$tras2","onDrop","updateBlockAfterMove_","fireMoveEvent_","oldRoot","oldRootLoc","dragging","draggingLoc","intersectionMarker","intersectionMarkerLoc","wouldConnectBlock","getInsertionMarkers","applyConnections","queueRender","scheduleSnapAndBump","root","isSuperior","id","difference","moveBy","res","parent","getParent"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/components/blockly/custom/ChildBasedDragger.ts"],"sourcesContent":["import * as Blockly from 'blockly'\n\nexport class ChildBasedDragger extends Blockly.BlockDragger {\n  private originalDraggingBlock: Blockly.BlockSvg\n  private childDraggedConnectionManager_: Blockly.InsertionMarkerManager\n\n  /* same as parent's dragTarget but can't use the one from parent because it's private */\n  private myDragTarget_: Blockly.IDragTarget | null = null\n\n  constructor(block: Blockly.BlockSvg, workspace: Blockly.WorkspaceSvg) {\n    super(block, workspace)\n    this.originalDraggingBlock = block\n    this.draggingBlock_ = this.getRoot(block)\n\n    /** Object that keeps track of connections on dragged blocks. */\n    this.draggedConnectionManager_ = new Blockly.InsertionMarkerManager(\n      this.getRoot(this.draggingBlock_),\n    )\n\n    this.childDraggedConnectionManager_ = new Blockly.InsertionMarkerManager(\n      this.originalDraggingBlock,\n    )\n\n    /**\n     * The location of the top left corner of the dragging block at the\n     * beginning of the drag in workspace coordinates.\n     */\n    this.startXY_ = this.getRoot(this.draggingBlock_).getRelativeToSurfaceXY()\n  }\n\n  public dispose(): void {\n    super.dispose()\n\n    if (this.childDraggedConnectionManager_) {\n      this.childDraggedConnectionManager_.dispose()\n    }\n  }\n\n  protected override shouldDisconnect_(healStack: boolean): boolean {\n    return !!(\n      this.originalDraggingBlock.getChildren(true).length > 0 ||\n      (healStack &&\n        this.originalDraggingBlock.previousConnection &&\n        this.originalDraggingBlock.previousConnection.targetBlock())\n    )\n  }\n\n  /**\n   * Disconnects the block and moves it to a new location.\n   *\n   * @param healStack Whether or not to heal the stack after disconnecting.\n   * @param currentDragDeltaXY How far the pointer has moved from the position\n   *     at mouse down, in pixel units.\n   */\n  protected override disconnectBlock_(\n    healStack: boolean,\n    currentDragDeltaXY: Blockly.utils.Coordinate,\n  ) {\n    const childBlocks = this.originalDraggingBlock.getChildren(true)\n    childBlocks.forEach((childBlock) => childBlock.unplug(healStack))\n\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY)\n    const newLoc = Blockly.utils.Coordinate.sum(this.startXY_, delta)\n\n    this.draggingBlock_.translate(newLoc.x, newLoc.y)\n    Blockly.blockAnimations.disconnectUiEffect(this.draggingBlock_)\n    this.draggedConnectionManager_.updateAvailableConnections()\n\n    this.childDraggedConnectionManager_.updateAvailableConnections()\n  }\n\n  drag(e: PointerEvent, currentDragDeltaXY: Blockly.utils.Coordinate): void {\n    super.drag(e, currentDragDeltaXY)\n\n    const delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY)\n\n    const oldDragTarget = this.myDragTarget_\n    this.myDragTarget_ = this.workspace_.getDragTarget(e)\n\n    this.childDraggedConnectionManager_.update(delta, this.myDragTarget_)\n    const oldWouldDeleteBlock2 = this.workspace_.trashcan?.wouldDelete(this.draggingBlock_, false)\n    this.wouldDeleteBlock_ = this.childDraggedConnectionManager_.wouldDeleteBlock\n    if (oldWouldDeleteBlock2 !== this.wouldDeleteBlock_) {\n      // Prevent unnecessary add/remove class calls.\n      this.updateCursorDuringBlockDrag_()\n    }\n\n    // Call drag enter/exit/over after wouldDeleteBlock is called in\n    // InsertionMarkerManager.update.\n    if (this.myDragTarget_ !== oldDragTarget) {\n      oldDragTarget && oldDragTarget.onDragExit(this.originalDraggingBlock)\n      this.myDragTarget_ && this.myDragTarget_.onDragEnter(this.originalDraggingBlock)\n    }\n    this.myDragTarget_ && this.myDragTarget_.onDragOver(this.originalDraggingBlock)\n  }\n\n  endDrag(e: PointerEvent, currentDragDeltaXY: Blockly.utils.Coordinate): void {\n    super.endDrag(e, currentDragDeltaXY)\n\n    if (this.myDragTarget_) {\n      this.myDragTarget_.onDrop(this.originalDraggingBlock)\n\n      if (this.workspace_.trashcan?.wouldDelete(this.draggingBlock_, false)) {\n        this.draggingBlock_.dispose(true, true)\n      }\n    }\n  }\n\n  protected updateBlockAfterMove_(): void {\n    this.fireMoveEvent_()\n    const oldRoot = this.draggingBlock_\n    const oldRootLoc = oldRoot.getRelativeToSurfaceXY()\n    const dragging = this.originalDraggingBlock\n    const draggingLoc = dragging.getRelativeToSurfaceXY()\n    let intersectionMarker\n    let intersectionMarkerLoc\n\n    if (this.draggedConnectionManager_.wouldConnectBlock()) {\n      intersectionMarker = this.draggedConnectionManager_.getInsertionMarkers()[0]\n      intersectionMarkerLoc = intersectionMarker.getRelativeToSurfaceXY()\n\n      // Applying connections also rerenders the relevant blocks.\n      this.draggedConnectionManager_.applyConnections()\n    } else if (this.childDraggedConnectionManager_.wouldConnectBlock()) {\n      intersectionMarker = this.childDraggedConnectionManager_.getInsertionMarkers()[0]\n      intersectionMarkerLoc = intersectionMarker.getRelativeToSurfaceXY()\n      this.childDraggedConnectionManager_.applyConnections()\n    } else {\n      this.draggingBlock_.queueRender()\n    }\n    this.draggingBlock_.scheduleSnapAndBump()\n\n    if (intersectionMarkerLoc) {\n      const root = this.getRoot(this.draggingBlock_)\n      const isSuperior = oldRoot.id === root.id\n\n      if (isSuperior) {\n        const delta = Blockly.utils.Coordinate.difference(intersectionMarkerLoc, draggingLoc)\n\n        root.moveBy(delta.x, delta.y)\n      } else {\n        const delta = Blockly.utils.Coordinate.difference(oldRootLoc, intersectionMarkerLoc)\n\n        root.moveBy(delta.x, delta.y)\n      }\n    }\n  }\n\n  getInsertionMarkers(): Blockly.BlockSvg[] {\n    const res = super.getInsertionMarkers()\n\n    if (\n      this.childDraggedConnectionManager_ &&\n      this.childDraggedConnectionManager_.getInsertionMarkers\n    ) {\n      return this.childDraggedConnectionManager_.getInsertionMarkers()\n    }\n\n    return res\n  }\n\n  private getRoot(block: Blockly.BlockSvg): Blockly.BlockSvg {\n    let parent = block.getParent()\n\n    while (parent) {\n      block = parent\n      parent = block.getParent()\n    }\n\n    return block\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}