{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`;\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)`${len} >= ${min}`;\n      if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n    it.items = true;\n    const valid = gen.name(\"valid\");\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n    cxt.result(valid, () => cxt.reset());\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)`${count}++`);\n      if (max === undefined) {\n        gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","error","message","_ref","params","min","max","undefined","str","_ref2","_","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","setParams","checkStrictMode","fail","alwaysValidSchema","cond","pass","items","valid","name","validateItems","if","break","let","validateItemsWithCount","result","reset","schValid","count","checkLimits","_valid","block","forRange","i","subschema","dataProp","dataPropType","Type","Num","compositeRule","assign","exports","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/applicator/contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}