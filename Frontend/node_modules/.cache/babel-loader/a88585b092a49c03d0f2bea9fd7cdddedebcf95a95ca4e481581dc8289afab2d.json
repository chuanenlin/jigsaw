{"ast":null,"code":"var _jsxFileName = \"/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/context/WorkspaceContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useRef, useState } from 'react';\nimport { getAutoChain, makeBlockSearchCall } from '../api';\nimport { blocksList } from '../constants';\nimport { cloneDeep } from 'lodash';\nimport { AutoChainService, BlockProcessorService } from '../service';\nimport { enqueueSnackbar } from 'notistack';\nimport { parseBlockData } from './util';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport let BlockProcessStatus = /*#__PURE__*/function (BlockProcessStatus) {\n  BlockProcessStatus[\"IDLE\"] = \"IDLE\";\n  BlockProcessStatus[\"STARTED\"] = \"STARTED\";\n  BlockProcessStatus[\"FINISHED\"] = \"FINISHED\";\n  BlockProcessStatus[\"FAILED\"] = \"FAILED\";\n  return BlockProcessStatus;\n}({});\nexport let RunStatus = /*#__PURE__*/function (RunStatus) {\n  RunStatus[\"IDLE\"] = \"IDLE\";\n  RunStatus[\"LOADING\"] = \"LOADING\";\n  return RunStatus;\n}({});\nexport let StatusSource = /*#__PURE__*/function (StatusSource) {\n  StatusSource[\"BLOCK_PROCESSOR\"] = \"BLOCK_PROCESSOR\";\n  return StatusSource;\n}({});\n\n/**\n * Block data that is used for processing\n * @param blocklyBlock - blockly block\n * @param blockData - block data from constants\n * @param processStatus - status of the block processing\n * @param inputs - inputs of the block (output of the previous block)\n * @param output - output of the block\n */\n\nconst WorkspaceContext = /*#__PURE__*/createContext(undefined);\nexport const useWorkspaceContext = () => {\n  _s();\n  return useContext(WorkspaceContext);\n};\n_s(useWorkspaceContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const WorkspaceContextProvider = _ref => {\n  _s2();\n  let {\n    children\n  } = _ref;\n  const [workspace, setWorkspace] = useState(undefined);\n  const [selectedBlocklyBlock, setSelectedBlocklyBlock] = useState(undefined);\n  const [selectedProcessableBlock, setSelectedProcessableBlock] = useState(undefined);\n  const processableBlocksRef = useRef(new Map());\n  const setProcessableBlocks = blocks => {\n    processableBlocksRef.current = blocks;\n  };\n  const selectedBlocklyBlockIdRef = useRef();\n  const setSelectedBlocklyBlockId = blockId => {\n    selectedBlocklyBlockIdRef.current = blockId;\n  };\n  const curBlockProcessorService = useRef();\n  const setCurBlockProcessorService = blockProcessorService => {\n    curBlockProcessorService.current = blockProcessorService;\n  };\n  const [workspaceStatus, setWorkspaceStatus] = useState({\n    runStatus: RunStatus.IDLE\n  });\n  const [visibleBlockIds, setVisibleBlockIds] = useState(blocksList.map(block => block.id) || []);\n  const [blockFilter, setBlockFilter] = useState();\n\n  /**\n   * Sets model of the selected block in the workspaceBlocks map and update the map\n   * @param block - blockly block\n   * @param model - parameters model\n   */\n  const setBlockParametersModel = (block, model) => {\n    const tempBlocks = new Map(processableBlocksRef.current);\n    const blockInfo = tempBlocks.get(block.id);\n    if (blockInfo) {\n      blockInfo.blockData.blockParameters.model = model;\n      setProcessableBlocks(tempBlocks);\n    }\n  };\n\n  /**\n   * Updates the workspaceBlocks map with the corresponding blocks in the workspace\n   * Adds new blocks to the map as a new block is added to the workspace\n   * @param blocklyBlocks - blockly blocks in the workspace\n   */\n  const onBlocksChanged = blocklyBlocks => {\n    const processableBlocks = processableBlocksRef.current;\n    const newBlocks = blocklyBlocks.filter(block => !processableBlocks.has(block.id));\n    const newBlocksMap = new Map();\n    const removedBlocks = Array.from(processableBlocks.keys()).filter(blockId => !blocklyBlocks.some(block => block.id === blockId));\n    removedBlocks.forEach(blockId => {\n      processableBlocks.delete(blockId);\n    });\n    newBlocks.forEach(block => {\n      const blockDetails = blocksList.find(b => b.name === (block === null || block === void 0 ? void 0 : block.type));\n      if (block && blockDetails) {\n        var _blockDetails$blockPa2;\n        let model = {};\n\n        /**\n         * This is required for autochain.\n         * If a block is added to the workspace by autochain, it already should have a model\n         * and it's stored in the block.data property of the block (see {@link AutoChainService#addBlock})\n         */\n        if (blockDetails !== null && blockDetails !== void 0 && blockDetails.blockParameters) {\n          if (!block.data) {\n            var _blockDetails$blockPa;\n            model = blockDetails === null || blockDetails === void 0 ? void 0 : (_blockDetails$blockPa = blockDetails.blockParameters) === null || _blockDetails$blockPa === void 0 ? void 0 : _blockDetails$blockPa.model;\n          } else {\n            // model = JSON.parse(block.data)\n            model = parseBlockData(block.data).model;\n          }\n        }\n        if (blockDetails !== null && blockDetails !== void 0 && (_blockDetails$blockPa2 = blockDetails.blockParameters) !== null && _blockDetails$blockPa2 !== void 0 && _blockDetails$blockPa2.model) {\n          blockDetails.blockParameters.model = model;\n        }\n        newBlocksMap.set(block.id, {\n          blocklyBlock: block,\n          blockData: cloneDeep(blockDetails),\n          processStatus: BlockProcessStatus.IDLE\n        });\n      }\n    });\n    setProcessableBlocks(new Map([...processableBlocks, ...newBlocksMap]));\n  };\n\n  /**\n   * Updates the processableBlocks map when a block is processed.\n   * This is used for updating the block output and status\n   * @param block - blockly block\n   */\n  const onBlockProcessed = (block, blocksCount, processedBlocksCount) => {\n    const tmpWorkspaceBlocks = new Map(processableBlocksRef.current);\n    tmpWorkspaceBlocks.set(block.blocklyBlock.id, block);\n    setProcessableBlocks(tmpWorkspaceBlocks);\n    const message = `${processedBlocksCount + 1}/${blocksCount}: ${block.blockData.name}`;\n    setWorkspaceStatus({\n      runStatus: RunStatus.LOADING,\n      message,\n      source: StatusSource.BLOCK_PROCESSOR\n    });\n  };\n  const processBlocks = async () => {\n    if (!processableBlocksRef.current.size) {\n      return;\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.LOADING,\n      source: StatusSource.BLOCK_PROCESSOR\n    });\n    try {\n      const blockProcessorService = new BlockProcessorService(onBlockProcessed);\n      setCurBlockProcessorService(blockProcessorService);\n      await blockProcessorService.initiateProcessing(processableBlocksRef.current, selectedBlocklyBlockIdRef.current);\n    } catch (error) {\n      enqueueSnackbar(error.message, {\n        variant: 'error'\n      });\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.IDLE\n    });\n  };\n  const cancelBlocksProcess = () => {\n    var _curBlockProcessorSer;\n    setWorkspaceStatus({\n      runStatus: RunStatus.IDLE\n    });\n    (_curBlockProcessorSer = curBlockProcessorService.current) === null || _curBlockProcessorSer === void 0 ? void 0 : _curBlockProcessorSer.cancelProcessing();\n    setCurBlockProcessorService(null);\n  };\n\n  /**\n   * Returns the block parameters of the selected block (schema and model)\n   * @returns block parameters\n   */\n  const getSelectedBlockParameters = () => {\n    var _blocksList$find;\n    if (!selectedBlocklyBlock) {\n      return undefined;\n    }\n    if (processableBlocksRef.current.has(selectedBlocklyBlock.id)) {\n      var _processableBlocksRef;\n      return (_processableBlocksRef = processableBlocksRef.current.get(selectedBlocklyBlock.id)) === null || _processableBlocksRef === void 0 ? void 0 : _processableBlocksRef.blockData.blockParameters;\n    }\n    return (_blocksList$find = blocksList.find(block => block.name === selectedBlocklyBlock.type)) === null || _blocksList$find === void 0 ? void 0 : _blocksList$find.blockParameters;\n  };\n  const onAutoChain = async task => {\n    if (!workspace) {\n      return;\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.LOADING,\n      message: 'Loading the chain'\n    });\n    try {\n      const autoChainResponse = await getAutoChain(task);\n      await new AutoChainService(workspace, autoChainResponse.autochain_output).autoChain();\n    } catch (error) {\n      enqueueSnackbar(error.message, {\n        variant: 'error'\n      });\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.IDLE\n    });\n  };\n  const onBlockSearch = async searchPhrase => {\n    if (searchPhrase.length < 1) {\n      setVisibleBlockIds(blocksList.map(block => block.id) || []);\n      return;\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.LOADING,\n      message: 'Searching for blocks'\n    });\n    try {\n      const blockSearchResponse = await makeBlockSearchCall({\n        task: searchPhrase\n      });\n      const blockIds = blockSearchResponse.list_output.map(fn => fn.substring(0, fn.length - 2));\n      setVisibleBlockIds(blockIds);\n    } catch (error) {\n      enqueueSnackbar(error.message, {\n        variant: 'error'\n      });\n    }\n    setWorkspaceStatus({\n      runStatus: RunStatus.IDLE\n    });\n  };\n  const onSelectedWorkspaceBlockChanged = block => {\n    if (!block) {\n      setSelectedBlocklyBlock(undefined);\n      setSelectedProcessableBlock(undefined);\n      return;\n    }\n    setSelectedBlocklyBlock(block);\n    setSelectedProcessableBlock(processableBlocksRef.current.get(block === null || block === void 0 ? void 0 : block.id));\n  };\n  return /*#__PURE__*/_jsxDEV(WorkspaceContext.Provider, {\n    value: {\n      workspace,\n      setWorkspace,\n      processableBlocks: processableBlocksRef.current,\n      selectedBlocklyBlock,\n      selectedProcessableBlock,\n      onSelectedWorkspaceBlockChanged,\n      setSelectedBlocklyBlockId,\n      setBlockParametersModel,\n      processBlocks,\n      cancelBlocksProcess,\n      onBlocksChanged,\n      getSelectedBlockParameters,\n      onAutoChain,\n      onBlockSearch,\n      visibleBlockIds,\n      setVisibleBlockIds,\n      workspaceStatus,\n      setBlockFilter,\n      blockFilter\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 313,\n    columnNumber: 5\n  }, this);\n};\n_s2(WorkspaceContextProvider, \"7QApzFzy8JcF+57Swc2fq5TvUlQ=\");\n_c = WorkspaceContextProvider;\nexport default WorkspaceContextProvider;\nvar _c;\n$RefreshReg$(_c, \"WorkspaceContextProvider\");","map":{"version":3,"names":["React","createContext","useContext","useRef","useState","getAutoChain","makeBlockSearchCall","blocksList","cloneDeep","AutoChainService","BlockProcessorService","enqueueSnackbar","parseBlockData","jsxDEV","_jsxDEV","BlockProcessStatus","RunStatus","StatusSource","WorkspaceContext","undefined","useWorkspaceContext","_s","WorkspaceContextProvider","_ref","_s2","children","workspace","setWorkspace","selectedBlocklyBlock","setSelectedBlocklyBlock","selectedProcessableBlock","setSelectedProcessableBlock","processableBlocksRef","Map","setProcessableBlocks","blocks","current","selectedBlocklyBlockIdRef","setSelectedBlocklyBlockId","blockId","curBlockProcessorService","setCurBlockProcessorService","blockProcessorService","workspaceStatus","setWorkspaceStatus","runStatus","IDLE","visibleBlockIds","setVisibleBlockIds","map","block","id","blockFilter","setBlockFilter","setBlockParametersModel","model","tempBlocks","blockInfo","get","blockData","blockParameters","onBlocksChanged","blocklyBlocks","processableBlocks","newBlocks","filter","has","newBlocksMap","removedBlocks","Array","from","keys","some","forEach","delete","blockDetails","find","b","name","type","_blockDetails$blockPa2","data","_blockDetails$blockPa","set","blocklyBlock","processStatus","onBlockProcessed","blocksCount","processedBlocksCount","tmpWorkspaceBlocks","message","LOADING","source","BLOCK_PROCESSOR","processBlocks","size","initiateProcessing","error","variant","cancelBlocksProcess","_curBlockProcessorSer","cancelProcessing","getSelectedBlockParameters","_blocksList$find","_processableBlocksRef","onAutoChain","task","autoChainResponse","autochain_output","autoChain","onBlockSearch","searchPhrase","length","blockSearchResponse","blockIds","list_output","fn","substring","onSelectedWorkspaceBlockChanged","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/context/WorkspaceContext.tsx"],"sourcesContent":["import React, { createContext, PropsWithChildren, useContext, useRef, useState } from 'react'\nimport Blockly from 'blockly/core'\nimport { Block, BlockParameters } from '../types'\nimport { BlockResponse, getAutoChain, makeAutoChainCall, makeBlockSearchCall } from '../api'\nimport { blocksList } from '../constants'\nimport { cloneDeep } from 'lodash'\nimport { AutoChainService, BlockProcessorService } from '../service'\nimport { enqueueSnackbar } from 'notistack'\nimport { parseBlockData } from './util'\nimport { BlocklistFilter } from '../components/block-search'\n\nexport type BlockProcessOutput = BlockResponse\nexport type BlockProcessInputs = Record<string, BlockProcessOutput>\n\nexport enum BlockProcessStatus {\n  IDLE = 'IDLE',\n  STARTED = 'STARTED',\n  FINISHED = 'FINISHED',\n  FAILED = 'FAILED',\n}\n\nexport enum RunStatus {\n  IDLE = 'IDLE',\n  LOADING = 'LOADING',\n}\n\nexport enum StatusSource {\n  BLOCK_PROCESSOR = 'BLOCK_PROCESSOR',\n}\n\nexport interface WorkspaceStatus {\n  runStatus: RunStatus\n  source?: StatusSource\n  message?: string\n}\n\n/**\n * Block data that is used for processing\n * @param blocklyBlock - blockly block\n * @param blockData - block data from constants\n * @param processStatus - status of the block processing\n * @param inputs - inputs of the block (output of the previous block)\n * @param output - output of the block\n */\nexport interface ProcessableBlock {\n  blocklyBlock: Blockly.Block\n  blockData: Block\n  processStatus: BlockProcessStatus\n  inputs?: BlockProcessInputs\n  output?: BlockProcessOutput\n}\n\ninterface WorkspaceContextProps {\n  workspace?: Blockly.WorkspaceSvg\n  setWorkspace: (workspace: Blockly.WorkspaceSvg) => void\n  /**\n   * Map of blockly blocks and their corresponding block data\n   * This is kept to be used for processing the blocks (api calls)\n   */\n  processableBlocks: Map<string, ProcessableBlock>\n  selectedBlocklyBlock: Blockly.Block | undefined | null\n  onSelectedWorkspaceBlockChanged: (block: Blockly.Block | undefined | null) => void\n  setSelectedBlocklyBlockId: (blockId: string | undefined | null) => void\n\n  selectedProcessableBlock: ProcessableBlock | undefined\n  /**\n   * Sets model of the selected block in the workspaceBlocks map and update the map\n   * @param block - blockly block\n   * @param model - parameters model\n   */\n  setBlockParametersModel: (block: Blockly.Block, model: BlockParameters['model']) => void\n  /**\n   * Process all blocks in the workspaceBlocks map (make api calls) and updated the blocks\n   * in the map with the response\n   */\n  processBlocks: () => Promise<void>\n  cancelBlocksProcess: () => void\n  /**\n   * Updates the workspaceBlocks map with the corresponding blocks in the workspace\n   * @param blocklyBlocks - blockly blocks in the workspace\n   */\n  onBlocksChanged: (blocklyBlocks: Blockly.Block[]) => void\n  getSelectedBlockParameters: () => BlockParameters | undefined\n  workspaceStatus: WorkspaceStatus\n  onAutoChain: (prompt: string) => Promise<void>\n\n  visibleBlockIds: Array<string>\n  setVisibleBlockIds: (blockEndpoints: Array<string>) => void\n  onBlockSearch: (searchPhrase: string) => Promise<void>\n  setBlockFilter: (prompt: BlocklistFilter) => void\n  blockFilter: BlocklistFilter | undefined\n}\n\nconst WorkspaceContext = createContext<WorkspaceContextProps | undefined>(undefined)\n\nexport const useWorkspaceContext = () => useContext(WorkspaceContext) as WorkspaceContextProps\n\nexport const WorkspaceContextProvider = ({ children }: PropsWithChildren) => {\n  const [workspace, setWorkspace] = useState<WorkspaceContextProps['workspace'] | undefined>(\n    undefined,\n  )\n\n  const [selectedBlocklyBlock, setSelectedBlocklyBlock] =\n    useState<WorkspaceContextProps['selectedBlocklyBlock']>(undefined)\n\n  const [selectedProcessableBlock, setSelectedProcessableBlock] =\n    useState<WorkspaceContextProps['selectedProcessableBlock']>(undefined)\n\n  const processableBlocksRef = useRef<WorkspaceContextProps['processableBlocks']>(new Map())\n  const setProcessableBlocks = (blocks: WorkspaceContextProps['processableBlocks']) => {\n    processableBlocksRef.current = blocks\n  }\n\n  const selectedBlocklyBlockIdRef = useRef<string | undefined | null>()\n  const setSelectedBlocklyBlockId = (blockId: string | undefined | null) => {\n    selectedBlocklyBlockIdRef.current = blockId\n  }\n\n  const curBlockProcessorService = useRef<BlockProcessorService | null>()\n  const setCurBlockProcessorService = (blockProcessorService: BlockProcessorService | null) => {\n    curBlockProcessorService.current = blockProcessorService\n  }\n\n  const [workspaceStatus, setWorkspaceStatus] = useState<WorkspaceStatus>({\n    runStatus: RunStatus.IDLE,\n  })\n\n  const [visibleBlockIds, setVisibleBlockIds] = useState(blocksList.map((block) => block.id) || [])\n  const [blockFilter, setBlockFilter] = useState<BlocklistFilter>()\n\n  /**\n   * Sets model of the selected block in the workspaceBlocks map and update the map\n   * @param block - blockly block\n   * @param model - parameters model\n   */\n  const setBlockParametersModel = (block: Blockly.Block, model: BlockParameters['model']) => {\n    const tempBlocks = new Map(processableBlocksRef.current)\n\n    const blockInfo = tempBlocks.get(block.id)\n    if (blockInfo) {\n      blockInfo.blockData.blockParameters!.model = model\n      setProcessableBlocks(tempBlocks)\n    }\n  }\n\n  /**\n   * Updates the workspaceBlocks map with the corresponding blocks in the workspace\n   * Adds new blocks to the map as a new block is added to the workspace\n   * @param blocklyBlocks - blockly blocks in the workspace\n   */\n  const onBlocksChanged = (blocklyBlocks: Blockly.Block[]) => {\n    const processableBlocks = processableBlocksRef.current\n    const newBlocks = blocklyBlocks.filter((block) => !processableBlocks.has(block.id))\n    const newBlocksMap = new Map<string, ProcessableBlock>()\n\n    const removedBlocks = Array.from(processableBlocks.keys()).filter(\n      (blockId) => !blocklyBlocks.some((block) => block.id === blockId),\n    )\n\n    removedBlocks.forEach((blockId) => {\n      processableBlocks.delete(blockId)\n    })\n\n    newBlocks.forEach((block) => {\n      const blockDetails = blocksList.find((b) => b.name === block?.type)\n      if (block && blockDetails) {\n        let model: BlockParameters['model'] = {}\n\n        /**\n         * This is required for autochain.\n         * If a block is added to the workspace by autochain, it already should have a model\n         * and it's stored in the block.data property of the block (see {@link AutoChainService#addBlock})\n         */\n        if (blockDetails?.blockParameters) {\n          if (!block.data) {\n            model = blockDetails?.blockParameters?.model\n          } else {\n            // model = JSON.parse(block.data)\n            model = parseBlockData(block.data).model!\n          }\n        }\n\n        if (blockDetails?.blockParameters?.model) {\n          blockDetails.blockParameters.model = model\n        }\n\n        newBlocksMap.set(block.id, {\n          blocklyBlock: block,\n          blockData: cloneDeep(blockDetails),\n          processStatus: BlockProcessStatus.IDLE,\n        })\n      }\n    })\n\n    setProcessableBlocks(new Map([...processableBlocks, ...newBlocksMap]))\n  }\n\n  /**\n   * Updates the processableBlocks map when a block is processed.\n   * This is used for updating the block output and status\n   * @param block - blockly block\n   */\n  const onBlockProcessed = (\n    block: ProcessableBlock,\n    blocksCount: number,\n    processedBlocksCount: number,\n  ) => {\n    const tmpWorkspaceBlocks = new Map(processableBlocksRef.current)\n    tmpWorkspaceBlocks.set(block.blocklyBlock.id, block)\n    setProcessableBlocks(tmpWorkspaceBlocks)\n\n    const message = `${processedBlocksCount + 1}/${blocksCount}: ${block.blockData.name}`\n\n    setWorkspaceStatus({\n      runStatus: RunStatus.LOADING,\n      message,\n      source: StatusSource.BLOCK_PROCESSOR,\n    })\n  }\n\n  const processBlocks = async () => {\n    if (!processableBlocksRef.current.size) {\n      return\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.LOADING, source: StatusSource.BLOCK_PROCESSOR })\n\n    try {\n      const blockProcessorService = new BlockProcessorService(onBlockProcessed)\n      setCurBlockProcessorService(blockProcessorService)\n      await blockProcessorService.initiateProcessing(\n        processableBlocksRef.current,\n        selectedBlocklyBlockIdRef.current,\n      )\n    } catch (error) {\n      enqueueSnackbar((error as Error).message, { variant: 'error' })\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.IDLE })\n  }\n\n  const cancelBlocksProcess = () => {\n    setWorkspaceStatus({ runStatus: RunStatus.IDLE })\n    curBlockProcessorService.current?.cancelProcessing()\n    setCurBlockProcessorService(null)\n  }\n\n  /**\n   * Returns the block parameters of the selected block (schema and model)\n   * @returns block parameters\n   */\n  const getSelectedBlockParameters = () => {\n    if (!selectedBlocklyBlock) {\n      return undefined\n    }\n\n    if (processableBlocksRef.current.has(selectedBlocklyBlock.id)) {\n      return processableBlocksRef.current.get(selectedBlocklyBlock.id)?.blockData.blockParameters\n    }\n\n    return blocksList.find((block) => block.name === selectedBlocklyBlock.type)?.blockParameters\n  }\n\n  const onAutoChain = async (task: string) => {\n    if (!workspace) {\n      return\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.LOADING, message: 'Loading the chain' })\n\n    try {\n      const autoChainResponse = await getAutoChain(task)\n      await new AutoChainService(workspace, autoChainResponse.autochain_output).autoChain()\n    } catch (error) {\n      enqueueSnackbar((error as Error).message, { variant: 'error' })\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.IDLE })\n  }\n\n  const onBlockSearch = async (searchPhrase: string) => {\n    if (searchPhrase.length < 1) {\n      setVisibleBlockIds(blocksList.map((block) => block.id) || [])\n      return\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.LOADING, message: 'Searching for blocks' })\n\n    try {\n      const blockSearchResponse = await makeBlockSearchCall({ task: searchPhrase })\n\n      const blockIds = blockSearchResponse.list_output.map((fn) => fn.substring(0, fn.length - 2))\n\n      setVisibleBlockIds(blockIds)\n    } catch (error) {\n      enqueueSnackbar((error as Error).message, { variant: 'error' })\n    }\n\n    setWorkspaceStatus({ runStatus: RunStatus.IDLE })\n  }\n\n  const onSelectedWorkspaceBlockChanged = (block: Blockly.Block | undefined | null) => {\n    if (!block) {\n      setSelectedBlocklyBlock(undefined)\n      setSelectedProcessableBlock(undefined)\n      return\n    }\n    setSelectedBlocklyBlock(block)\n    setSelectedProcessableBlock(processableBlocksRef.current.get(block?.id))\n  }\n\n  return (\n    <WorkspaceContext.Provider\n      value={{\n        workspace,\n        setWorkspace,\n        processableBlocks: processableBlocksRef.current,\n        selectedBlocklyBlock,\n        selectedProcessableBlock,\n        onSelectedWorkspaceBlockChanged,\n        setSelectedBlocklyBlockId,\n        setBlockParametersModel,\n        processBlocks,\n        cancelBlocksProcess,\n        onBlocksChanged,\n        getSelectedBlockParameters,\n        onAutoChain,\n        onBlockSearch,\n        visibleBlockIds,\n        setVisibleBlockIds,\n        workspaceStatus,\n        setBlockFilter,\n        blockFilter,\n      }}\n    >\n      {children}\n    </WorkspaceContext.Provider>\n  )\n}\n\nexport default WorkspaceContextProvider\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}