{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { get } from 'lodash';\nconst generateCacheKeySegment = (args, paths) => {\n  return Object.entries(paths).map(_ref => {\n    let [index, pathOrBool] = _ref;\n    const arg = args[Number(index)];\n    if (pathOrBool === true) {\n      return JSON.stringify(arg);\n    } else if (Array.isArray(pathOrBool)) {\n      return pathOrBool.map(path => JSON.stringify(get(arg, path))).join('|');\n    }\n    return '';\n  }).join('::');\n};\n\n/**\n * Decorator for caching the results of method calls based on specified argument properties.\n * The cache keys are generated based on the provided `comparePaths` and `clearPaths`.\n * The function also supports asynchronous method calls by waiting for Promises to resolve\n * before caching their results. If a Promise is rejected, the error is thrown and no result is cached.\n *\n * @param params - Configuration object for the decorator.\n * @param params.clearPaths - Paths used to determine\n *        when to clear the cache. If `true`, the entire argument is used; if an array, only the specified\n *        paths in the argument are used. The key is the index of the argument.\n * @param params.comparePaths - Paths used to generate\n *        the cache key. If `true`, the entire argument is considered; if an array, only the specified\n *        paths in the argument are used for comparison. The key is the index of the argument.\n * @returns - Method decorator that applies caching logic to the method.\n */\nexport const cached = _ref2 => {\n  let {\n    clearPaths = {},\n    comparePaths = {}\n  } = _ref2;\n  const clearKeySegment = clearPaths ? generateCacheKeySegment : () => '';\n  const uniqueSeparator = '@@';\n  return function (target, propertyKey, descriptor) {\n    const originalMethod = descriptor.value;\n    const cache = new Map();\n    descriptor.value = async function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const clearSegment = clearKeySegment(args, clearPaths);\n      const cacheSegment = generateCacheKeySegment(args, comparePaths);\n      const cacheKey = `${clearSegment}${uniqueSeparator}${cacheSegment}`;\n      if (cache.has(cacheKey)) {\n        var _cache$get;\n        console.log('HIT:', cacheKey);\n        return (_cache$get = cache.get(cacheKey)) === null || _cache$get === void 0 ? void 0 : _cache$get.value;\n      }\n      console.log('MISS:', cacheKey);\n\n      // Clear cache based on clearPaths\n      if (clearSegment) {\n        Array.from(cache.keys()).forEach(key => {\n          if (key.startsWith(`${clearSegment}${uniqueSeparator}`)) {\n            console.log('CLEAR: ', key);\n            cache.delete(key);\n          }\n        });\n      }\n      const result = await originalMethod.apply(this, args);\n      cache.set(cacheKey, {\n        args: [...args],\n        value: result\n      });\n      return result;\n    };\n    return descriptor;\n  };\n};","map":{"version":3,"names":["get","generateCacheKeySegment","args","paths","Object","entries","map","_ref","index","pathOrBool","arg","Number","JSON","stringify","Array","isArray","path","join","cached","_ref2","clearPaths","comparePaths","clearKeySegment","uniqueSeparator","target","propertyKey","descriptor","originalMethod","value","cache","Map","_len","arguments","length","_key","clearSegment","cacheSegment","cacheKey","has","_cache$get","console","log","from","keys","forEach","key","startsWith","delete","result","apply","set"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/utils/cached.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { get } from 'lodash'\n\ntype CacheEntry = {\n  args: any[]\n  value: any\n}\n\ninterface CachedParams {\n  clearPaths: Record<number, boolean | Array<string>>\n  comparePaths: Record<number, boolean | Array<string>>\n}\n\nconst generateCacheKeySegment = (\n  args: any[],\n  paths: Record<number, boolean | Array<string>>,\n): string => {\n  return Object.entries(paths)\n    .map(([index, pathOrBool]) => {\n      const arg = args[Number(index)]\n      if (pathOrBool === true) {\n        return JSON.stringify(arg)\n      } else if (Array.isArray(pathOrBool)) {\n        return pathOrBool.map((path) => JSON.stringify(get(arg, path))).join('|')\n      }\n      return ''\n    })\n    .join('::')\n}\n\n/**\n * Decorator for caching the results of method calls based on specified argument properties.\n * The cache keys are generated based on the provided `comparePaths` and `clearPaths`.\n * The function also supports asynchronous method calls by waiting for Promises to resolve\n * before caching their results. If a Promise is rejected, the error is thrown and no result is cached.\n *\n * @param params - Configuration object for the decorator.\n * @param params.clearPaths - Paths used to determine\n *        when to clear the cache. If `true`, the entire argument is used; if an array, only the specified\n *        paths in the argument are used. The key is the index of the argument.\n * @param params.comparePaths - Paths used to generate\n *        the cache key. If `true`, the entire argument is considered; if an array, only the specified\n *        paths in the argument are used for comparison. The key is the index of the argument.\n * @returns - Method decorator that applies caching logic to the method.\n */\nexport const cached = ({ clearPaths = {}, comparePaths = {} }: CachedParams) => {\n  const clearKeySegment = clearPaths ? generateCacheKeySegment : () => ''\n  const uniqueSeparator = '@@'\n\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value\n    const cache = new Map<string, CacheEntry>()\n\n    descriptor.value = async function (...args: any[]) {\n      const clearSegment = clearKeySegment(args, clearPaths)\n      const cacheSegment = generateCacheKeySegment(args, comparePaths)\n      const cacheKey = `${clearSegment}${uniqueSeparator}${cacheSegment}`\n\n      if (cache.has(cacheKey)) {\n        console.log('HIT:', cacheKey)\n        return cache.get(cacheKey)?.value\n      }\n\n      console.log('MISS:', cacheKey)\n\n      // Clear cache based on clearPaths\n      if (clearSegment) {\n        Array.from(cache.keys()).forEach((key) => {\n          if (key.startsWith(`${clearSegment}${uniqueSeparator}`)) {\n            console.log('CLEAR: ', key)\n            cache.delete(key)\n          }\n        })\n      }\n\n      const result = await originalMethod.apply(this, args)\n      cache.set(cacheKey, { args: [...args], value: result })\n      return result\n    }\n\n    return descriptor\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}