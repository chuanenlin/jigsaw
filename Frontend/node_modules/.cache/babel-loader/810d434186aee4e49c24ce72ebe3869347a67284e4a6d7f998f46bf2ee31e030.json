{"ast":null,"code":"import { __rest } from \"tslib\";\nimport invariant from 'invariant';\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport lowerCase from 'lodash/lowerCase';\nimport memoize from 'lodash/memoize';\nimport upperFirst from 'lodash/upperFirst';\nimport { Bridge, joinName } from 'uniforms';\nfunction fieldInvariant(name, condition) {\n  invariant(condition, 'Field not found in schema: \"%s\"', name);\n}\nfunction resolveRef(reference, schema) {\n  invariant(reference.startsWith('#'), 'Reference is not an internal reference, and only such are allowed: \"%s\"', reference);\n  const resolvedReference = reference.split('/').filter(part => part && part !== '#').reduce((definition, next) => definition[next], schema);\n  invariant(resolvedReference, 'Reference not found in schema: \"%s\"', reference);\n  return resolvedReference;\n}\nfunction resolveRefIfNeeded(partial, schema) {\n  if (!('$ref' in partial)) {\n    return partial;\n  }\n  const {\n      $ref\n    } = partial,\n    partialWithoutRef = __rest(partial, [\"$ref\"]);\n  return resolveRefIfNeeded(\n  // @ts-expect-error The `partial` and `schema` should be typed more precisely.\n  Object.assign({}, partialWithoutRef, resolveRef($ref, schema)), schema);\n}\nconst partialNames = ['allOf', 'anyOf', 'oneOf'];\nconst propsToRemove = ['default', 'enum', 'format', 'isRequired', 'title', 'uniforms'];\nconst propsToRename = [['maxItems', 'maxCount'], ['maximum', 'max'], ['minItems', 'minCount'], ['minimum', 'min'], ['multipleOf', 'step']];\nfunction pathToName(path) {\n  path = path.startsWith('/') ? path.replace(/\\//g, '.').replace(/~0/g, '~').replace(/~1/g, '/') : path.replace(/\\[('|\")(.+?)\\1\\]/g, '.$2').replace(/\\[(.+?)\\]/g, '.$1').replace(/\\\\'/g, \"'\");\n  return path.slice(1);\n}\nfunction isValidatorResult(value) {\n  return typeof value === 'object' && value !== null && Array.isArray(value.details);\n}\nexport default class JSONSchemaBridge extends Bridge {\n  constructor(\n  // FIXME: The `schema` should be typed more precisely.\n  schema, validator) {\n    super();\n    this.schema = schema;\n    this.validator = validator;\n    this.schema = resolveRefIfNeeded(schema, schema);\n    this._compiledSchema = {\n      '': this.schema\n    };\n    // Memoize for performance and referential equality.\n    this.getField = memoize(this.getField.bind(this));\n    this.getInitialValue = memoize(this.getInitialValue.bind(this));\n    this.getSubfields = memoize(this.getSubfields.bind(this));\n    this.getType = memoize(this.getType.bind(this));\n  }\n  getError(name, error) {\n    const details = isValidatorResult(error) && error.details;\n    if (!details) {\n      return null;\n    }\n    const nameParts = joinName(null, name).map(joinName.unescape);\n    const unescapedName = joinName(nameParts);\n    const rootName = joinName(nameParts.slice(0, -1));\n    const baseName = nameParts[nameParts.length - 1];\n    const scopedError = details.find(error => {\n      var _a;\n      const rawPath = (_a = error.instancePath) !== null && _a !== void 0 ? _a : error.dataPath;\n      const path = rawPath ? pathToName(rawPath) : '';\n      return unescapedName === path || rootName === path && error.params && baseName === error.params.missingProperty;\n    });\n    return scopedError || null;\n  }\n  getErrorMessage(name, error) {\n    const scopedError = this.getError(name, error);\n    return (scopedError === null || scopedError === void 0 ? void 0 : scopedError.message) || '';\n  }\n  getErrorMessages(error) {\n    if (!error) {\n      return [];\n    }\n    if (isValidatorResult(error)) {\n      const {\n        details\n      } = error;\n      return details.map(error => error.message || '');\n    }\n    if (error instanceof Error) {\n      return [error.message];\n    }\n    if (typeof error === 'object') {\n      return [];\n    }\n    return [String(error)];\n  }\n  getField(name) {\n    return joinName(null, name).reduce((definition, next, index, array) => {\n      var _a, _b, _c;\n      var _d;\n      const prevName = joinName(array.slice(0, index));\n      const nextName = joinName(prevName, next);\n      const definitionCache = (_a = (_d = this._compiledSchema)[nextName]) !== null && _a !== void 0 ? _a : _d[nextName] = {};\n      definitionCache.isRequired = !!(((_b = definition.required) === null || _b === void 0 ? void 0 : _b.includes(next)) || ((_c = this._compiledSchema[prevName].required) === null || _c === void 0 ? void 0 : _c.includes(next)));\n      if (next === '$' || next === '' + parseInt(next, 10)) {\n        fieldInvariant(name, definition.type === 'array');\n        definition = Array.isArray(definition.items) ? definition.items[parseInt(next, 10)] : definition.items;\n        fieldInvariant(name, !!definition);\n      } else if (definition.type === 'object') {\n        fieldInvariant(name, !!definition.properties);\n        definition = definition.properties[joinName.unescape(next)];\n        fieldInvariant(name, !!definition);\n      } else {\n        let nextFound = false;\n        partialNames.forEach(partialName => {\n          var _a;\n          (_a = definition[partialName]) === null || _a === void 0 ? void 0 : _a.forEach(partialElement => {\n            if (!nextFound) {\n              partialElement = resolveRefIfNeeded(partialElement, this.schema);\n              if (next in partialElement.properties) {\n                definition = partialElement.properties[next];\n                nextFound = true;\n              }\n            }\n          });\n        });\n        fieldInvariant(name, nextFound);\n      }\n      definition = resolveRefIfNeeded(definition, this.schema);\n      // Naive computation of combined type, properties and required.\n      const required = definition.required ? definition.required.slice() : [];\n      const properties = definition.properties ? Object.assign({}, definition.properties) : {};\n      partialNames.forEach(partialName => {\n        var _a;\n        (_a = definition[partialName]) === null || _a === void 0 ? void 0 : _a.forEach(partial => {\n          partial = resolveRefIfNeeded(partial, this.schema);\n          if (partial.required) {\n            required.push(...partial.required);\n          }\n          Object.assign(properties, partial.properties);\n          if (!definitionCache.type && partial.type) {\n            definitionCache.type = partial.type;\n          }\n        });\n      });\n      if (required.length > 0) {\n        definitionCache.required = required;\n      }\n      if (!isEmpty(properties)) {\n        definitionCache.properties = properties;\n      }\n      return definition;\n    }, this.schema);\n  }\n  getInitialValue(name) {\n    var _a;\n    const field = this.getField(name);\n    const {\n      default: defaultValue = (_a = field.default) !== null && _a !== void 0 ? _a : get(this.schema.default, name),\n      type = field.type\n    } = this._compiledSchema[name];\n    if (defaultValue !== undefined) {\n      return cloneDeep(defaultValue);\n    }\n    if (type === 'array') {\n      const item = this.getInitialValue(joinName(name, '$'));\n      if (item === undefined) {\n        return [];\n      }\n      const length = field.minItems || 0;\n      return Array.from({\n        length\n      }, () => item);\n    }\n    if (type === 'object') {\n      const value = {};\n      this.getSubfields(name).forEach(key => {\n        const initialValue = this.getInitialValue(joinName(name, key));\n        if (initialValue !== undefined) {\n          value[key] = initialValue;\n        }\n      });\n      return value;\n    }\n    return undefined;\n  }\n  getProps(name) {\n    var _a, _b, _c;\n    const field = this.getField(name);\n    const props = Object.assign({}, field, field.uniforms, this._compiledSchema[name]);\n    (_a = props.label) !== null && _a !== void 0 ? _a : props.label = (_b = props.title) !== null && _b !== void 0 ? _b : upperFirst(lowerCase(joinName(null, name).slice(-1)[0]));\n    if (field.type === 'number') {\n      props.decimal = true;\n    }\n    if (((_c = field.uniforms) === null || _c === void 0 ? void 0 : _c.type) !== undefined) {\n      props.type = field.uniforms.type;\n    }\n    if (props.required === undefined) {\n      props.required = props.isRequired;\n    }\n    if (props.type === field.type) {\n      delete props.type;\n    }\n    let options = props.options;\n    if (options) {\n      if (!Array.isArray(options)) {\n        options = Object.entries(options).map(_ref => {\n          let [key, value] = _ref;\n          return {\n            key,\n            label: key,\n            value\n          };\n        });\n      }\n    } else if (props.enum) {\n      options = Object.values(props.enum).map(value => ({\n        value\n      }));\n    }\n    propsToRename.forEach(_ref2 => {\n      let [key, newKey] = _ref2;\n      if (key in props) {\n        props[newKey] = props[key];\n        delete props[key];\n      }\n    });\n    propsToRemove.forEach(key => {\n      if (key in props) {\n        delete props[key];\n      }\n    });\n    return Object.assign(props, {\n      options\n    });\n  }\n  getSubfields() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    const field = this.getField(name);\n    const {\n      properties = field.properties,\n      type = field.type\n    } = this._compiledSchema[name];\n    if (type === 'object' && properties) {\n      return Object.keys(properties).map(joinName.escape);\n    }\n    return [];\n  }\n  getType(name) {\n    const {\n      type: _type,\n      format: fieldFormat\n    } = this.getField(name);\n    const {\n      type: fieldType = _type\n    } = this._compiledSchema[name];\n    if (fieldFormat === 'date-time') {\n      return Date;\n    }\n    if (fieldType === 'string') {\n      return String;\n    }\n    if (fieldType === 'number') {\n      return Number;\n    }\n    if (fieldType === 'integer') {\n      return Number;\n    }\n    if (fieldType === 'object') {\n      return Object;\n    }\n    if (fieldType === 'array') {\n      return Array;\n    }\n    if (fieldType === 'boolean') {\n      return Boolean;\n    }\n    invariant(fieldType !== 'null', 'Field \"%s\" can not be represented as a type null', name);\n    return fieldType;\n  }\n  getValidator() {\n    return this.validator;\n  }\n}","map":{"version":3,"names":["__rest","invariant","cloneDeep","get","isEmpty","lowerCase","memoize","upperFirst","Bridge","joinName","fieldInvariant","name","condition","resolveRef","reference","schema","startsWith","resolvedReference","split","filter","part","reduce","definition","next","resolveRefIfNeeded","partial","$ref","partialWithoutRef","Object","assign","partialNames","propsToRemove","propsToRename","pathToName","path","replace","slice","isValidatorResult","value","Array","isArray","details","JSONSchemaBridge","constructor","validator","_compiledSchema","getField","bind","getInitialValue","getSubfields","getType","getError","error","nameParts","map","unescape","unescapedName","rootName","baseName","length","scopedError","find","_a","rawPath","instancePath","dataPath","params","missingProperty","getErrorMessage","message","getErrorMessages","Error","String","index","array","_b","_c","_d","prevName","nextName","definitionCache","isRequired","required","includes","parseInt","type","items","properties","nextFound","forEach","partialName","partialElement","push","field","default","defaultValue","undefined","item","minItems","from","key","initialValue","getProps","props","uniforms","label","title","decimal","options","entries","_ref","enum","values","_ref2","newKey","arguments","keys","escape","_type","format","fieldFormat","fieldType","Date","Number","Boolean","getValidator"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/uniforms-bridge-json-schema/esm/JSONSchemaBridge.js"],"sourcesContent":["import { __rest } from \"tslib\";\nimport invariant from 'invariant';\nimport cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\nimport lowerCase from 'lodash/lowerCase';\nimport memoize from 'lodash/memoize';\nimport upperFirst from 'lodash/upperFirst';\nimport { Bridge, joinName } from 'uniforms';\nfunction fieldInvariant(name, condition) {\n    invariant(condition, 'Field not found in schema: \"%s\"', name);\n}\nfunction resolveRef(reference, schema) {\n    invariant(reference.startsWith('#'), 'Reference is not an internal reference, and only such are allowed: \"%s\"', reference);\n    const resolvedReference = reference\n        .split('/')\n        .filter(part => part && part !== '#')\n        .reduce((definition, next) => definition[next], schema);\n    invariant(resolvedReference, 'Reference not found in schema: \"%s\"', reference);\n    return resolvedReference;\n}\nfunction resolveRefIfNeeded(partial, schema) {\n    if (!('$ref' in partial)) {\n        return partial;\n    }\n    const { $ref } = partial, partialWithoutRef = __rest(partial, [\"$ref\"]);\n    return resolveRefIfNeeded(\n    // @ts-expect-error The `partial` and `schema` should be typed more precisely.\n    Object.assign({}, partialWithoutRef, resolveRef($ref, schema)), schema);\n}\nconst partialNames = ['allOf', 'anyOf', 'oneOf'];\nconst propsToRemove = [\n    'default',\n    'enum',\n    'format',\n    'isRequired',\n    'title',\n    'uniforms',\n];\nconst propsToRename = [\n    ['maxItems', 'maxCount'],\n    ['maximum', 'max'],\n    ['minItems', 'minCount'],\n    ['minimum', 'min'],\n    ['multipleOf', 'step'],\n];\nfunction pathToName(path) {\n    path = path.startsWith('/')\n        ? path.replace(/\\//g, '.').replace(/~0/g, '~').replace(/~1/g, '/')\n        : path\n            .replace(/\\[('|\")(.+?)\\1\\]/g, '.$2')\n            .replace(/\\[(.+?)\\]/g, '.$1')\n            .replace(/\\\\'/g, \"'\");\n    return path.slice(1);\n}\nfunction isValidatorResult(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        Array.isArray(value.details));\n}\nexport default class JSONSchemaBridge extends Bridge {\n    constructor(\n    // FIXME: The `schema` should be typed more precisely.\n    schema, validator) {\n        super();\n        this.schema = schema;\n        this.validator = validator;\n        this.schema = resolveRefIfNeeded(schema, schema);\n        this._compiledSchema = { '': this.schema };\n        // Memoize for performance and referential equality.\n        this.getField = memoize(this.getField.bind(this));\n        this.getInitialValue = memoize(this.getInitialValue.bind(this));\n        this.getSubfields = memoize(this.getSubfields.bind(this));\n        this.getType = memoize(this.getType.bind(this));\n    }\n    getError(name, error) {\n        const details = isValidatorResult(error) && error.details;\n        if (!details) {\n            return null;\n        }\n        const nameParts = joinName(null, name).map(joinName.unescape);\n        const unescapedName = joinName(nameParts);\n        const rootName = joinName(nameParts.slice(0, -1));\n        const baseName = nameParts[nameParts.length - 1];\n        const scopedError = details.find(error => {\n            var _a;\n            const rawPath = (_a = error.instancePath) !== null && _a !== void 0 ? _a : error.dataPath;\n            const path = rawPath ? pathToName(rawPath) : '';\n            return (unescapedName === path ||\n                (rootName === path &&\n                    error.params &&\n                    baseName === error.params.missingProperty));\n        });\n        return scopedError || null;\n    }\n    getErrorMessage(name, error) {\n        const scopedError = this.getError(name, error);\n        return (scopedError === null || scopedError === void 0 ? void 0 : scopedError.message) || '';\n    }\n    getErrorMessages(error) {\n        if (!error) {\n            return [];\n        }\n        if (isValidatorResult(error)) {\n            const { details } = error;\n            return details.map(error => error.message || '');\n        }\n        if (error instanceof Error) {\n            return [error.message];\n        }\n        if (typeof error === 'object') {\n            return [];\n        }\n        return [String(error)];\n    }\n    getField(name) {\n        return joinName(null, name).reduce((definition, next, index, array) => {\n            var _a, _b, _c;\n            var _d;\n            const prevName = joinName(array.slice(0, index));\n            const nextName = joinName(prevName, next);\n            const definitionCache = ((_a = (_d = this._compiledSchema)[nextName]) !== null && _a !== void 0 ? _a : (_d[nextName] = {}));\n            definitionCache.isRequired = !!(((_b = definition.required) === null || _b === void 0 ? void 0 : _b.includes(next)) ||\n                ((_c = this._compiledSchema[prevName].required) === null || _c === void 0 ? void 0 : _c.includes(next)));\n            if (next === '$' || next === '' + parseInt(next, 10)) {\n                fieldInvariant(name, definition.type === 'array');\n                definition = Array.isArray(definition.items)\n                    ? definition.items[parseInt(next, 10)]\n                    : definition.items;\n                fieldInvariant(name, !!definition);\n            }\n            else if (definition.type === 'object') {\n                fieldInvariant(name, !!definition.properties);\n                definition = definition.properties[joinName.unescape(next)];\n                fieldInvariant(name, !!definition);\n            }\n            else {\n                let nextFound = false;\n                partialNames.forEach(partialName => {\n                    var _a;\n                    (_a = definition[partialName]) === null || _a === void 0 ? void 0 : _a.forEach((partialElement) => {\n                        if (!nextFound) {\n                            partialElement = resolveRefIfNeeded(partialElement, this.schema);\n                            if (next in partialElement.properties) {\n                                definition = partialElement.properties[next];\n                                nextFound = true;\n                            }\n                        }\n                    });\n                });\n                fieldInvariant(name, nextFound);\n            }\n            definition = resolveRefIfNeeded(definition, this.schema);\n            // Naive computation of combined type, properties and required.\n            const required = definition.required ? definition.required.slice() : [];\n            const properties = definition.properties\n                ? Object.assign({}, definition.properties)\n                : {};\n            partialNames.forEach(partialName => {\n                var _a;\n                (_a = definition[partialName]) === null || _a === void 0 ? void 0 : _a.forEach((partial) => {\n                    partial = resolveRefIfNeeded(partial, this.schema);\n                    if (partial.required) {\n                        required.push(...partial.required);\n                    }\n                    Object.assign(properties, partial.properties);\n                    if (!definitionCache.type && partial.type) {\n                        definitionCache.type = partial.type;\n                    }\n                });\n            });\n            if (required.length > 0) {\n                definitionCache.required = required;\n            }\n            if (!isEmpty(properties)) {\n                definitionCache.properties = properties;\n            }\n            return definition;\n        }, this.schema);\n    }\n    getInitialValue(name) {\n        var _a;\n        const field = this.getField(name);\n        const { default: defaultValue = (_a = field.default) !== null && _a !== void 0 ? _a : get(this.schema.default, name), type = field.type, } = this._compiledSchema[name];\n        if (defaultValue !== undefined) {\n            return cloneDeep(defaultValue);\n        }\n        if (type === 'array') {\n            const item = this.getInitialValue(joinName(name, '$'));\n            if (item === undefined) {\n                return [];\n            }\n            const length = field.minItems || 0;\n            return Array.from({ length }, () => item);\n        }\n        if (type === 'object') {\n            const value = {};\n            this.getSubfields(name).forEach(key => {\n                const initialValue = this.getInitialValue(joinName(name, key));\n                if (initialValue !== undefined) {\n                    value[key] = initialValue;\n                }\n            });\n            return value;\n        }\n        return undefined;\n    }\n    getProps(name) {\n        var _a, _b, _c;\n        const field = this.getField(name);\n        const props = Object.assign({}, field, field.uniforms, this._compiledSchema[name]);\n        (_a = props.label) !== null && _a !== void 0 ? _a : (props.label = (_b = props.title) !== null && _b !== void 0 ? _b : upperFirst(lowerCase(joinName(null, name).slice(-1)[0])));\n        if (field.type === 'number') {\n            props.decimal = true;\n        }\n        if (((_c = field.uniforms) === null || _c === void 0 ? void 0 : _c.type) !== undefined) {\n            props.type = field.uniforms.type;\n        }\n        if (props.required === undefined) {\n            props.required = props.isRequired;\n        }\n        if (props.type === field.type) {\n            delete props.type;\n        }\n        let options = props.options;\n        if (options) {\n            if (!Array.isArray(options)) {\n                options = Object.entries(options).map(([key, value]) => ({\n                    key,\n                    label: key,\n                    value,\n                }));\n            }\n        }\n        else if (props.enum) {\n            options = Object.values(props.enum).map(value => ({ value }));\n        }\n        propsToRename.forEach(([key, newKey]) => {\n            if (key in props) {\n                props[newKey] = props[key];\n                delete props[key];\n            }\n        });\n        propsToRemove.forEach(key => {\n            if (key in props) {\n                delete props[key];\n            }\n        });\n        return Object.assign(props, { options });\n    }\n    getSubfields(name = '') {\n        const field = this.getField(name);\n        const { properties = field.properties, type = field.type } = this._compiledSchema[name];\n        if (type === 'object' && properties) {\n            return Object.keys(properties).map(joinName.escape);\n        }\n        return [];\n    }\n    getType(name) {\n        const { type: _type, format: fieldFormat } = this.getField(name);\n        const { type: fieldType = _type } = this._compiledSchema[name];\n        if (fieldFormat === 'date-time') {\n            return Date;\n        }\n        if (fieldType === 'string') {\n            return String;\n        }\n        if (fieldType === 'number') {\n            return Number;\n        }\n        if (fieldType === 'integer') {\n            return Number;\n        }\n        if (fieldType === 'object') {\n            return Object;\n        }\n        if (fieldType === 'array') {\n            return Array;\n        }\n        if (fieldType === 'boolean') {\n            return Boolean;\n        }\n        invariant(fieldType !== 'null', 'Field \"%s\" can not be represented as a type null', name);\n        return fieldType;\n    }\n    getValidator() {\n        return this.validator;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}