{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport { ContinuousToolbox } from './ContinuousToolbox';\nimport { ContinuousFlyoutMetrics } from './ContinuousMetricsFlyout';\n\n/**\n * the amount the flyout should be shifted downwards to accommodate the search bar\n */\nconst SHIFT_FLYOUT_BY = 50; // px\nconst FLYOUT_WIDTH = 471;\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /** @override */\n  constructor(workspaceOptions) {\n    super(workspaceOptions);\n\n    /**\n     * List of scroll positions for each category.\n     * @type {!Array<{name: string, position: !Object}>}\n     */\n    this.scrollPositions = [];\n\n    /**\n     * Target scroll position, used to smoothly scroll to a given category\n     * location when selected.\n     * @type {?number}\n     */\n    this.scrollTarget = null;\n\n    /**\n     * The percentage of the distance to the scrollTarget that should be\n     * scrolled at a time. Lower values will produce a smoother, slower scroll.\n     * @type {number}\n     */\n    this.scrollAnimationFraction = 0.3;\n\n    /**\n     * Whether to recycle blocks when refreshing the flyout. When false, do not\n     * allow anything to be recycled. The default is to recycle.\n     * @type {boolean}\n     * @private\n     */\n    this.recyclingEnabled_ = true;\n    this.workspace_.setMetricsManager(new ContinuousFlyoutMetrics(this.workspace_, this));\n    this.workspace_.addChangeListener(e => {\n      if (e.type === Blockly.Events.VIEWPORT_CHANGE) {\n        this.selectCategoryByScrollPosition_(-this.workspace_.scrollY);\n      }\n    });\n    this.autoClose = false;\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   * @returns {!ContinuousToolbox} Toolbox that owns this flyout.\n   * @private\n   */\n  getParentToolbox_() {\n    const toolbox = this.targetWorkspace.getToolbox();\n    return (/** @type {!ContinuousToolbox} */toolbox\n    );\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   * @package\n   */\n  recordScrollPositions() {\n    this.scrollPositions = [];\n    const categoryLabels = this.buttons_.filter(button => button.isLabel() && this.getParentToolbox_().getCategoryByName(button.getButtonText()));\n    for (const button of categoryLabels) {\n      if (button.isLabel()) {\n        this.scrollPositions.push({\n          name: button.getButtonText(),\n          position: button.getPosition()\n        });\n      }\n    }\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   * @param {string} name Category name.\n   * @returns {?Object} Scroll position for given category, or null if not\n   *     found.\n   * @package\n   */\n  getCategoryScrollPosition(name) {\n    for (const scrollInfo of this.scrollPositions) {\n      if (scrollInfo.name === name) {\n        return scrollInfo.position;\n      }\n    }\n    console.warn(`Scroll position not recorded for category ${name}`);\n    return null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   * @param {number} position Current scroll position of the workspace.\n   * @private\n   */\n  selectCategoryByScrollPosition_(position) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) {\n      return;\n    }\n    const scaledPosition = Math.round(position / this.workspace_.scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (let i = this.scrollPositions.length - 1; i >= 0; i--) {\n      const category = this.scrollPositions[i];\n      if (scaledPosition >= category.position.y) {\n        this.getParentToolbox_().selectCategoryByName(category.name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls flyout to given position.\n   * @param {number} position The x coordinate to scroll to.\n   */\n  scrollTo(position) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.workspace_.getMetrics();\n    this.scrollTarget = Math.min(position * this.workspace_.scale, metrics.scrollHeight - metrics.viewHeight + 1400);\n    this.stepScrollAnimation_();\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   * @private\n   */\n  stepScrollAnimation_() {\n    if (!this.scrollTarget) {\n      return;\n    }\n    const currentScrollPos = -this.workspace_.scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.workspace_.scrollbar.setY(this.scrollTarget);\n      this.scrollTarget = null;\n      return;\n    }\n    this.workspace_.scrollbar.setY(currentScrollPos + diff * this.scrollAnimationFraction);\n    requestAnimationFrame(this.stepScrollAnimation_.bind(this));\n  }\n\n  /**\n   * Add additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content\n   *    metrics for the flyout.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *    for the flyout.\n   * @returns {number} Additional bottom padding.\n   */\n  calculateBottomPadding(contentMetrics, viewMetrics) {\n    if (this.scrollPositions.length > 0) {\n      const lastCategory = this.scrollPositions[this.scrollPositions.length - 1];\n      const lastPosition = lastCategory.position.y * this.workspace_.scale;\n      const lastCategoryHeight = contentMetrics.height - lastPosition;\n      if (lastCategoryHeight < viewMetrics.height) {\n        return viewMetrics.height - lastCategoryHeight + 400;\n      }\n    }\n    // To have extra space at the bottom of the flyout\n    // when filtering blocks, with semantic search.\n    // otherwise, it causes flickering when scrolling to the bottom\n    return 400;\n  }\n\n  /** @override */\n  getX() {\n    if (this.isVisible() && this.targetWorkspace.toolboxPosition === this.toolboxPosition_ && this.targetWorkspace.getToolbox() && this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT) {\n      // This makes it so blocks cannot go under the flyout in RTL mode.\n      return this.targetWorkspace.getMetricsManager().getViewMetrics().width;\n    }\n    return super.getX();\n  }\n  getY() {\n    return SHIFT_FLYOUT_BY;\n  }\n  getHeight() {\n    return this.height_ - SHIFT_FLYOUT_BY;\n  }\n\n  /**\n   * overriding to shorten the height of\n   * the flyout based on the shift amount\n   * used for the search bar\n   */\n  position() {\n    super.position();\n    const x = this.getX();\n    const y = this.getY();\n    this.height_ = this.height_ - SHIFT_FLYOUT_BY;\n    this.width_ = FLYOUT_WIDTH;\n    this.positionAt_(this.width_, this.height_, x, y);\n  }\n  getFlyoutScale() {\n    return 0.932;\n  }\n\n  /**\n   * @override\n   */\n  show(flyoutDef) {\n    super.show(flyoutDef);\n    this.recordScrollPositions();\n    this.workspace_.resizeContents();\n  }\n  layout_(contents, gaps) {\n    this.workspace_.scale = this.targetWorkspace.scale;\n    const cursorX = this.MARGIN;\n    let cursorY = this.MARGIN;\n    for (let i = 0, item; item = contents[i]; i++) {\n      if (item.type === 'block') {\n        const block = item.block;\n        const allBlocks = block.getDescendants(false);\n        for (let j = 0, child; child = allBlocks[j]; j++) {\n          // Mark blocks as being inside a flyout.  This is used to detect and\n          // prevent the closure of the flyout if the user right-clicks on such\n          // a block.\n          child.isInFlyout = true;\n        }\n        const root = block.getSvgRoot();\n        const blockHW = block.getHeightWidth();\n\n        // need to move by block width because input/output\n        // directions are flipped\n        const moveX = cursorX + blockHW.width;\n        block.moveBy(moveX, cursorY);\n        const rect = this.createRect_(block, this.RTL ? moveX - blockHW.width : moveX, cursorY, blockHW, i);\n        this.addBlockListeners_(root, block, rect);\n        cursorY += blockHW.height + gaps[i];\n      } else if (item.type === 'button') {\n        const button = item.button;\n        this.initFlyoutButton_(button, cursorX, cursorY);\n        cursorY += button.height + gaps[i];\n      }\n    }\n  }\n\n  /**\n   * Determine if this block can be recycled in the flyout.  Blocks that have no\n   * variables and are not dynamic shadows can be recycled.\n   * @param {!Blockly.BlockSvg} block The block to attempt to recycle.\n   * @returns {boolean} True if the block can be recycled.\n   * @protected\n   */\n  blockIsRecyclable_(block) {\n    if (!this.recyclingEnabled_) {\n      return false;\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (block.mutationToDom && block.domToMutation) {\n      return false;\n    }\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field instanceof Blockly.FieldVariable) {\n          return false;\n        }\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) {\n            return false;\n          }\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = /** @type {Blockly.BlockSvg} */input.connection.targetBlock();\n        if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   * @param {function(!Blockly.BlockSvg):boolean} func The function used to\n   *     determine if a block is recyclable.\n   * @public\n   */\n  setBlockIsRecyclable(func) {\n    this.blockIsRecyclable_ = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   * @param {boolean} isEnabled True to allow blocks to be recycled, false\n   *     otherwise.\n   * @public\n   */\n  setRecyclingEnabled(isEnabled) {\n    this.recyclingEnabled_ = isEnabled;\n  }\n  getBlocks() {\n    return this.mats_.map(rect => rect === null || rect === void 0 ? void 0 : rect.tooltip).filter(block => block !== undefined);\n  }\n}","map":{"version":3,"names":["Blockly","ContinuousToolbox","ContinuousFlyoutMetrics","SHIFT_FLYOUT_BY","FLYOUT_WIDTH","ContinuousFlyout","VerticalFlyout","constructor","workspaceOptions","scrollPositions","scrollTarget","scrollAnimationFraction","recyclingEnabled_","workspace_","setMetricsManager","addChangeListener","e","type","Events","VIEWPORT_CHANGE","selectCategoryByScrollPosition_","scrollY","autoClose","getParentToolbox_","toolbox","targetWorkspace","getToolbox","recordScrollPositions","categoryLabels","buttons_","filter","button","isLabel","getCategoryByName","getButtonText","push","name","position","getPosition","getCategoryScrollPosition","scrollInfo","console","warn","scaledPosition","Math","round","scale","i","length","category","y","selectCategoryByName","scrollTo","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation_","currentScrollPos","diff","abs","scrollbar","setY","requestAnimationFrame","bind","calculateBottomPadding","contentMetrics","viewMetrics","lastCategory","lastPosition","lastCategoryHeight","height","getX","isVisible","toolboxPosition","toolboxPosition_","utils","Position","LEFT","getMetricsManager","getViewMetrics","width","getY","getHeight","height_","x","width_","positionAt_","getFlyoutScale","show","flyoutDef","resizeContents","layout_","contents","gaps","cursorX","MARGIN","cursorY","item","block","allBlocks","getDescendants","j","child","isInFlyout","root","getSvgRoot","blockHW","getHeightWidth","moveX","moveBy","rect","createRect_","RTL","addBlockListeners_","initFlyoutButton_","blockIsRecyclable_","mutationToDom","domToMutation","input","inputList","field","fieldRow","FieldVariable","FieldDropdown","isOptionListDynamic","connection","targetBlock","setBlockIsRecyclable","func","setRecyclingEnabled","isEnabled","getBlocks","mats_","map","tooltip","undefined"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/components/blockly/continuous-toolbox/ContinuousFlyout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core'\nimport { ContinuousToolbox } from './ContinuousToolbox'\nimport { ContinuousFlyoutMetrics } from './ContinuousMetricsFlyout'\n\n/**\n * the amount the flyout should be shifted downwards to accommodate the search bar\n */\nconst SHIFT_FLYOUT_BY = 50 // px\nconst FLYOUT_WIDTH = 471\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /** @override */\n  constructor(workspaceOptions) {\n    super(workspaceOptions)\n\n    /**\n     * List of scroll positions for each category.\n     * @type {!Array<{name: string, position: !Object}>}\n     */\n    this.scrollPositions = []\n\n    /**\n     * Target scroll position, used to smoothly scroll to a given category\n     * location when selected.\n     * @type {?number}\n     */\n    this.scrollTarget = null\n\n    /**\n     * The percentage of the distance to the scrollTarget that should be\n     * scrolled at a time. Lower values will produce a smoother, slower scroll.\n     * @type {number}\n     */\n    this.scrollAnimationFraction = 0.3\n\n    /**\n     * Whether to recycle blocks when refreshing the flyout. When false, do not\n     * allow anything to be recycled. The default is to recycle.\n     * @type {boolean}\n     * @private\n     */\n    this.recyclingEnabled_ = true\n\n    this.workspace_.setMetricsManager(new ContinuousFlyoutMetrics(this.workspace_, this))\n\n    this.workspace_.addChangeListener((e) => {\n      if (e.type === Blockly.Events.VIEWPORT_CHANGE) {\n        this.selectCategoryByScrollPosition_(-this.workspace_.scrollY)\n      }\n    })\n\n    this.autoClose = false\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   * @returns {!ContinuousToolbox} Toolbox that owns this flyout.\n   * @private\n   */\n  getParentToolbox_() {\n    const toolbox = this.targetWorkspace.getToolbox()\n    return /** @type {!ContinuousToolbox} */ (toolbox)\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   * @package\n   */\n  recordScrollPositions() {\n    this.scrollPositions = []\n    const categoryLabels = this.buttons_.filter(\n      (button) =>\n        button.isLabel() && this.getParentToolbox_().getCategoryByName(button.getButtonText()),\n    )\n    for (const button of categoryLabels) {\n      if (button.isLabel()) {\n        this.scrollPositions.push({\n          name: button.getButtonText(),\n          position: button.getPosition(),\n        })\n      }\n    }\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   * @param {string} name Category name.\n   * @returns {?Object} Scroll position for given category, or null if not\n   *     found.\n   * @package\n   */\n  getCategoryScrollPosition(name) {\n    for (const scrollInfo of this.scrollPositions) {\n      if (scrollInfo.name === name) {\n        return scrollInfo.position\n      }\n    }\n    console.warn(`Scroll position not recorded for category ${name}`)\n    return null\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   * @param {number} position Current scroll position of the workspace.\n   * @private\n   */\n  selectCategoryByScrollPosition_(position) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) {\n      return\n    }\n    const scaledPosition = Math.round(position / this.workspace_.scale)\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (let i = this.scrollPositions.length - 1; i >= 0; i--) {\n      const category = this.scrollPositions[i]\n      if (scaledPosition >= category.position.y) {\n        this.getParentToolbox_().selectCategoryByName(category.name)\n        return\n      }\n    }\n  }\n\n  /**\n   * Scrolls flyout to given position.\n   * @param {number} position The x coordinate to scroll to.\n   */\n  scrollTo(position) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.workspace_.getMetrics()\n    this.scrollTarget = Math.min(\n      position * this.workspace_.scale,\n      metrics.scrollHeight - metrics.viewHeight + 1400,\n    )\n\n    this.stepScrollAnimation_()\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   * @private\n   */\n  stepScrollAnimation_() {\n    if (!this.scrollTarget) {\n      return\n    }\n\n    const currentScrollPos = -this.workspace_.scrollY\n    const diff = this.scrollTarget - currentScrollPos\n    if (Math.abs(diff) < 1) {\n      this.workspace_.scrollbar.setY(this.scrollTarget)\n      this.scrollTarget = null\n      return\n    }\n    this.workspace_.scrollbar.setY(currentScrollPos + diff * this.scrollAnimationFraction)\n\n    requestAnimationFrame(this.stepScrollAnimation_.bind(this))\n  }\n\n  /**\n   * Add additional padding to the bottom of the flyout if needed,\n   * in order to make it possible to scroll to the top of the last category.\n   * @param {!Blockly.MetricsManager.ContainerRegion} contentMetrics Content\n   *    metrics for the flyout.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *    for the flyout.\n   * @returns {number} Additional bottom padding.\n   */\n  calculateBottomPadding(contentMetrics, viewMetrics) {\n    if (this.scrollPositions.length > 0) {\n      const lastCategory = this.scrollPositions[this.scrollPositions.length - 1]\n      const lastPosition = lastCategory.position.y * this.workspace_.scale\n      const lastCategoryHeight = contentMetrics.height - lastPosition\n      if (lastCategoryHeight < viewMetrics.height) {\n        return viewMetrics.height - lastCategoryHeight + 400\n      }\n    }\n    // To have extra space at the bottom of the flyout\n    // when filtering blocks, with semantic search.\n    // otherwise, it causes flickering when scrolling to the bottom\n    return 400\n  }\n\n  /** @override */\n  getX() {\n    if (\n      this.isVisible() &&\n      this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n      this.targetWorkspace.getToolbox() &&\n      this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT\n    ) {\n      // This makes it so blocks cannot go under the flyout in RTL mode.\n      return this.targetWorkspace.getMetricsManager().getViewMetrics().width\n    }\n\n    return super.getX()\n  }\n\n  getY() {\n    return SHIFT_FLYOUT_BY\n  }\n\n  getHeight() {\n    return this.height_ - SHIFT_FLYOUT_BY\n  }\n\n  /**\n   * overriding to shorten the height of\n   * the flyout based on the shift amount\n   * used for the search bar\n   */\n  position() {\n    super.position()\n    const x = this.getX()\n    const y = this.getY()\n    this.height_ = this.height_ - SHIFT_FLYOUT_BY\n    this.width_ = FLYOUT_WIDTH\n    this.positionAt_(this.width_, this.height_, x, y)\n  }\n\n  getFlyoutScale() {\n    return 0.932\n  }\n\n  /**\n   * @override\n   */\n  show(flyoutDef) {\n    super.show(flyoutDef)\n    this.recordScrollPositions()\n    this.workspace_.resizeContents()\n  }\n\n  layout_(contents, gaps) {\n    this.workspace_.scale = this.targetWorkspace.scale\n    const cursorX = this.MARGIN\n    let cursorY = this.MARGIN\n\n    for (let i = 0, item; (item = contents[i]); i++) {\n      if (item.type === 'block') {\n        const block = item.block\n        const allBlocks = block.getDescendants(false)\n        for (let j = 0, child; (child = allBlocks[j]); j++) {\n          // Mark blocks as being inside a flyout.  This is used to detect and\n          // prevent the closure of the flyout if the user right-clicks on such\n          // a block.\n          child.isInFlyout = true\n        }\n        const root = block.getSvgRoot()\n        const blockHW = block.getHeightWidth()\n\n        // need to move by block width because input/output\n        // directions are flipped\n        const moveX = cursorX + blockHW.width\n\n        block.moveBy(moveX, cursorY)\n\n        const rect = this.createRect_(\n          block,\n          this.RTL ? moveX - blockHW.width : moveX,\n          cursorY,\n          blockHW,\n          i,\n        )\n\n        this.addBlockListeners_(root, block, rect)\n\n        cursorY += blockHW.height + gaps[i]\n      } else if (item.type === 'button') {\n        const button = item.button\n        this.initFlyoutButton_(button, cursorX, cursorY)\n        cursorY += button.height + gaps[i]\n      }\n    }\n  }\n\n  /**\n   * Determine if this block can be recycled in the flyout.  Blocks that have no\n   * variables and are not dynamic shadows can be recycled.\n   * @param {!Blockly.BlockSvg} block The block to attempt to recycle.\n   * @returns {boolean} True if the block can be recycled.\n   * @protected\n   */\n  blockIsRecyclable_(block) {\n    if (!this.recyclingEnabled_) {\n      return false\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (block.mutationToDom && block.domToMutation) {\n      return false\n    }\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field instanceof Blockly.FieldVariable) {\n          return false\n        }\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) {\n            return false\n          }\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = /** @type {Blockly.BlockSvg} */ (input.connection.targetBlock())\n        if (targetBlock && !this.blockIsRecyclable_(targetBlock)) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   * @param {function(!Blockly.BlockSvg):boolean} func The function used to\n   *     determine if a block is recyclable.\n   * @public\n   */\n  setBlockIsRecyclable(func) {\n    this.blockIsRecyclable_ = func\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   * @param {boolean} isEnabled True to allow blocks to be recycled, false\n   *     otherwise.\n   * @public\n   */\n  setRecyclingEnabled(isEnabled) {\n    this.recyclingEnabled_ = isEnabled\n  }\n\n  getBlocks() {\n    return this.mats_.map((rect) => rect?.tooltip).filter((block) => block !== undefined)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}