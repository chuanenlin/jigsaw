{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = require(\"./code\");\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n    return `${prefix}${ng.index++}`;\n  }\n  _nameGroup(prefix) {\n    var _a, _b;\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)`\\n`;\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = {\n      ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n  get() {\n    return this._scope;\n  }\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n  value(nameOrPrefix, value) {\n    var _a;\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n    if (vs) {\n      const _name = vs.get(valueKey);\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return (0, code_1._)`${scopeName}${name.scopePath}`;\n    });\n  }\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n    return code;\n  }\n}\nexports.ValueScope = ValueScope;","map":{"version":3,"names":["code_1","require","ValueError","Error","constructor","name","value","UsedValueState","exports","varKinds","const","Name","let","var","Scope","prefixes","parent","arguments","length","undefined","_names","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","ng","_nameGroup","index","_b","_a","has","ValueScopeName","nameStr","setValue","_ref","property","itemIndex","scopePath","_","line","ValueScope","opts","_values","_scope","scope","_n","lines","nil","get","ref","valueKey","key","vs","_name","Map","set","s","getValue","keyOrRef","scopeRefs","scopeName","values","_reduceValues","scopeCode","usedValues","getCode","code","valueCode","nameSet","forEach","Started","c","def","es5","Completed"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/compile/codegen/scope.ts"],"sourcesContent":["import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}