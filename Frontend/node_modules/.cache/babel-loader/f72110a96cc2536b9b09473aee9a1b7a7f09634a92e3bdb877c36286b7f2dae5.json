{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt) {\n    const {\n      schema,\n      it\n    } = cxt;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    cxt.ok((0, code_1.validateArray)(cxt));\n  }\n};\nfunction validateTuple(cxt, extraItems) {\n  let schArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cxt.schema;\n  const {\n    gen,\n    parentSchema,\n    data,\n    keyword,\n    it\n  } = cxt;\n  checkStrictTuple(parentSchema);\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n  const valid = gen.name(\"valid\");\n  const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n  schArr.forEach((sch, i) => {\n    if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n    gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({\n      keyword,\n      schemaProp: i,\n      dataProp: i\n    }, valid));\n    cxt.ok(valid);\n  });\n  function checkStrictTuple(sch) {\n    const {\n      opts,\n      errSchemaPath\n    } = it;\n    const l = schArr.length;\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n      (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n    }\n  }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","code_1","def","keyword","type","schemaType","before","code","cxt","schema","it","Array","isArray","validateTuple","items","alwaysValidSchema","ok","validateArray","extraItems","schArr","arguments","length","undefined","gen","parentSchema","data","checkStrictTuple","opts","unevaluated","mergeEvaluated","valid","name","len","const","_","forEach","sch","i","if","subschema","schemaProp","dataProp","errSchemaPath","l","fullTuple","minItems","maxItems","strictTuples","msg","checkStrictMode","exports","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/applicator/items.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n"],"mappings":";;;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,MAAA,GAAAF,OAAA;AAEA,MAAMG,GAAG,GAA0B;EACjCC,OAAO,EAAE,OAAO;EAChBC,IAAI,EAAE,OAAO;EACbC,UAAU,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,SAAS,CAAC;EAC1CC,MAAM,EAAE,aAAa;EACrBC,IAAIA,CAACC,GAAe;IAClB,MAAM;MAACC,MAAM;MAAEC;IAAE,CAAC,GAAGF,GAAG;IACxB,IAAIG,KAAK,CAACC,OAAO,CAACH,MAAM,CAAC,EAAE,OAAOI,aAAa,CAACL,GAAG,EAAE,iBAAiB,EAAEC,MAAM,CAAC;IAC/EC,EAAE,CAACI,KAAK,GAAG,IAAI;IACf,IAAI,IAAAd,MAAA,CAAAe,iBAAiB,EAACL,EAAE,EAAED,MAAM,CAAC,EAAE;IACnCD,GAAG,CAACQ,EAAE,CAAC,IAAAf,MAAA,CAAAgB,aAAa,EAACT,GAAG,CAAC,CAAC;EAC5B;CACD;AAED,SAAgBK,aAAaA,CAC3BL,GAAe,EACfU,UAAkB,EACc;EAAA,IAAhCC,MAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAsBZ,GAAG,CAACC,MAAM;EAEhC,MAAM;IAACc,GAAG;IAAEC,YAAY;IAAEC,IAAI;IAAEtB,OAAO;IAAEO;EAAE,CAAC,GAAGF,GAAG;EAClDkB,gBAAgB,CAACF,YAAY,CAAC;EAC9B,IAAId,EAAE,CAACiB,IAAI,CAACC,WAAW,IAAIT,MAAM,CAACE,MAAM,IAAIX,EAAE,CAACI,KAAK,KAAK,IAAI,EAAE;IAC7DJ,EAAE,CAACI,KAAK,GAAGd,MAAA,CAAA6B,cAAc,CAACf,KAAK,CAACS,GAAG,EAAEJ,MAAM,CAACE,MAAM,EAAEX,EAAE,CAACI,KAAK,CAAC;;EAE/D,MAAMgB,KAAK,GAAGP,GAAG,CAACQ,IAAI,CAAC,OAAO,CAAC;EAC/B,MAAMC,GAAG,GAAGT,GAAG,CAACU,KAAK,CAAC,KAAK,EAAE,IAAAnC,SAAA,CAAAoC,CAAC,IAAGT,IAAI,SAAS,CAAC;EAC/CN,MAAM,CAACgB,OAAO,CAAC,CAACC,GAAc,EAAEC,CAAS,KAAI;IAC3C,IAAI,IAAArC,MAAA,CAAAe,iBAAiB,EAACL,EAAE,EAAE0B,GAAG,CAAC,EAAE;IAChCb,GAAG,CAACe,EAAE,CAAC,IAAAxC,SAAA,CAAAoC,CAAC,IAAGF,GAAG,MAAMK,CAAC,EAAE,EAAE,MACvB7B,GAAG,CAAC+B,SAAS,CACX;MACEpC,OAAO;MACPqC,UAAU,EAAEH,CAAC;MACbI,QAAQ,EAAEJ;KACX,EACDP,KAAK,CACN,CACF;IACDtB,GAAG,CAACQ,EAAE,CAACc,KAAK,CAAC;EACf,CAAC,CAAC;EAEF,SAASJ,gBAAgBA,CAACU,GAAoB;IAC5C,MAAM;MAACT,IAAI;MAAEe;IAAa,CAAC,GAAGhC,EAAE;IAChC,MAAMiC,CAAC,GAAGxB,MAAM,CAACE,MAAM;IACvB,MAAMuB,SAAS,GAAGD,CAAC,KAAKP,GAAG,CAACS,QAAQ,KAAKF,CAAC,KAAKP,GAAG,CAACU,QAAQ,IAAIV,GAAG,CAAClB,UAAU,CAAC,KAAK,KAAK,CAAC;IACzF,IAAIS,IAAI,CAACoB,YAAY,IAAI,CAACH,SAAS,EAAE;MACnC,MAAMI,GAAG,GAAG,IAAI7C,OAAO,QAAQwC,CAAC,oCAAoCzB,UAAU,4CAA4CwB,aAAa,GAAG;MAC1I,IAAA1C,MAAA,CAAAiD,eAAe,EAACvC,EAAE,EAAEsC,GAAG,EAAErB,IAAI,CAACoB,YAAY,CAAC;;EAE/C;AACF;AApCAG,OAAA,CAAArC,aAAA,GAAAA,aAAA;AAsCAqC,OAAA,CAAAC,OAAA,GAAejD,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}