{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["code_1","require","codegen_1","util_1","util_2","def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","allSchemaProperties","alwaysValidPatterns","filter","p","alwaysValidSchema","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","Name","evaluatedPropsToName","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","checkStrictMode","forIn","key","_","usePattern","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","Type","Str","assign","not","break","exports","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}