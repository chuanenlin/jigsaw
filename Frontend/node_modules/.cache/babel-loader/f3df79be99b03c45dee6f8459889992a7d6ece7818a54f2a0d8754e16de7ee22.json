{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport { ContinuousFlyout } from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n  }\n\n  /** @override */\n  init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents_());\n    flyout.recordScrollPositions();\n\n    /**\n     * NOTE: @mohasarc has commented this out because it\n     * causes sudden shifts in the toolbox scrollbar when\n     * drag/dropping blocks from toolbox to workspace.\n     * however, not sure if it would cause any other side-effects\n     */\n    // this.workspace_.addChangeListener((e) => {\n    //   if (e.type === Blockly.Events.BLOCK_CREATE || e.type === Blockly.Events.BLOCK_DELETE) {\n    //     this.refreshSelection()\n    //   }\n    // })\n  }\n\n  /** @override */\n  getFlyout() {\n    return (/** @type {ContinuousFlyout} */super.getFlyout()\n    );\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   * @returns {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.\n   * @private\n   */\n  getInitialFlyoutContents_() {\n    /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */\n    let contents = [];\n    for (const toolboxItem of this.contents_) {\n      if (toolboxItem instanceof Blockly.ToolboxCategory) {\n        if (toolboxItem.getContents().length) {\n          // Create a label node to go at the top of the category\n          contents.push({\n            kind: 'LABEL',\n            text: toolboxItem.getName()\n          });\n        }\n        /**\n         * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|\n         *    Blockly.utils.toolbox.FlyoutItemInfo}\n         */\n        let itemContents = toolboxItem.getContents();\n\n        // Handle custom categories (e.g. variables and functions)\n        if (typeof itemContents === 'string') {\n          itemContents = /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */{\n            custom: itemContents,\n            kind: 'CATEGORY'\n          };\n        }\n        contents = contents.concat(itemContents);\n      }\n    }\n    return contents;\n  }\n\n  /** @override */\n  refreshSelection() {\n    this.getFlyout().show(this.getInitialFlyoutContents_());\n  }\n\n  /** @override */\n  updateFlyout_(_oldItem, newItem) {\n    if (newItem) {\n      const target = this.getFlyout().getCategoryScrollPosition(newItem.name_).y;\n      this.getFlyout().scrollTo(target);\n    }\n  }\n\n  /** @override */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Should not deselect if the same category is clicked again.\n    return oldItem && oldItem !== newItem;\n  }\n\n  /**\n   * Gets a category by name.\n   * @param {string} name Name of category to get.\n   * @returns {?Blockly.ToolboxCategory} Category, or null if not\n   *    found.\n   * @package\n   */\n  getCategoryByName(name) {\n    const category = this.contents_.find(item => item instanceof Blockly.ToolboxCategory && item.isSelectable() && name === item.getName());\n    if (category) {\n      return (/** @type {!Blockly.ToolboxCategory} */category\n      );\n    }\n    return null;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   * @param {string} name Name of category to select.\n   * @package\n   */\n  selectCategoryByName(name) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) {\n      return;\n    }\n    const oldItem = this.selectedItem_;\n    if (this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /** @override */\n  getClientRect() {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\nBlockly.Css.register(`\n.categoryBubble {\n  margin: 0 auto 0.125rem;\n  border-radius: 100%;\n  border: 1px solid;\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.blocklyTreeRow {\n  height: initial;\n  padding: 3px 0;\n}\n.blocklyTreeRowContentContainer {\n  display: flex;\n  flex-direction: column;\n}\n.blocklyTreeLabel {\n  margin: auto;\n}\n`);","map":{"version":3,"names":["Blockly","ContinuousFlyout","ContinuousToolbox","Toolbox","constructor","workspace","init","flyout","getFlyout","show","getInitialFlyoutContents_","recordScrollPositions","contents","toolboxItem","contents_","ToolboxCategory","getContents","length","push","kind","text","getName","itemContents","custom","concat","refreshSelection","updateFlyout_","_oldItem","newItem","target","getCategoryScrollPosition","name_","y","scrollTo","shouldDeselectItem_","oldItem","getCategoryByName","name","category","find","item","isSelectable","selectCategoryByName","selectedItem_","deselectItem_","shouldSelectItem_","selectItem_","getClientRect","autoClose","Css","register"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/components/blockly/continuous-toolbox/ContinuousToolbox.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core'\nimport { ContinuousFlyout } from './ContinuousFlyout'\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /** @override */\n  constructor(workspace) {\n    super(workspace)\n  }\n\n  /** @override */\n  init() {\n    super.init()\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout()\n    flyout.show(this.getInitialFlyoutContents_())\n    flyout.recordScrollPositions()\n\n    /**\n     * NOTE: @mohasarc has commented this out because it\n     * causes sudden shifts in the toolbox scrollbar when\n     * drag/dropping blocks from toolbox to workspace.\n     * however, not sure if it would cause any other side-effects\n     */\n    // this.workspace_.addChangeListener((e) => {\n    //   if (e.type === Blockly.Events.BLOCK_CREATE || e.type === Blockly.Events.BLOCK_DELETE) {\n    //     this.refreshSelection()\n    //   }\n    // })\n  }\n\n  /** @override */\n  getFlyout() {\n    return /** @type {ContinuousFlyout} */ (super.getFlyout())\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   * @returns {!Blockly.utils.toolbox.FlyoutItemInfoArray} Flyout contents.\n   * @private\n   */\n  getInitialFlyoutContents_() {\n    /** @type {!Blockly.utils.toolbox.FlyoutItemInfoArray} */\n    let contents = []\n    for (const toolboxItem of this.contents_) {\n      if (toolboxItem instanceof Blockly.ToolboxCategory) {\n        if (toolboxItem.getContents().length) {\n          // Create a label node to go at the top of the category\n          contents.push({ kind: 'LABEL', text: toolboxItem.getName() })\n        }\n        /**\n         * @type {string|Blockly.utils.toolbox.FlyoutItemInfoArray|\n         *    Blockly.utils.toolbox.FlyoutItemInfo}\n         */\n        let itemContents = toolboxItem.getContents()\n\n        // Handle custom categories (e.g. variables and functions)\n        if (typeof itemContents === 'string') {\n          itemContents = /** @type {!Blockly.utils.toolbox.DynamicCategoryInfo} */ ({\n            custom: itemContents,\n            kind: 'CATEGORY',\n          })\n        }\n        contents = contents.concat(itemContents)\n      }\n    }\n    return contents\n  }\n\n  /** @override */\n  refreshSelection() {\n    this.getFlyout().show(this.getInitialFlyoutContents_())\n  }\n\n  /** @override */\n  updateFlyout_(_oldItem, newItem) {\n    if (newItem) {\n      const target = this.getFlyout().getCategoryScrollPosition(newItem.name_).y\n      this.getFlyout().scrollTo(target)\n    }\n  }\n\n  /** @override */\n  shouldDeselectItem_(oldItem, newItem) {\n    // Should not deselect if the same category is clicked again.\n    return oldItem && oldItem !== newItem\n  }\n\n  /**\n   * Gets a category by name.\n   * @param {string} name Name of category to get.\n   * @returns {?Blockly.ToolboxCategory} Category, or null if not\n   *    found.\n   * @package\n   */\n  getCategoryByName(name) {\n    const category = this.contents_.find(\n      (item) =>\n        item instanceof Blockly.ToolboxCategory && item.isSelectable() && name === item.getName(),\n    )\n    if (category) {\n      return /** @type {!Blockly.ToolboxCategory} */ (category)\n    }\n    return null\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   * @param {string} name Name of category to select.\n   * @package\n   */\n  selectCategoryByName(name) {\n    const newItem = this.getCategoryByName(name)\n    if (!newItem) {\n      return\n    }\n    const oldItem = this.selectedItem_\n\n    if (this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem)\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem)\n    }\n  }\n\n  /** @override */\n  getClientRect() {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout()\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect()\n    }\n    return super.getClientRect()\n  }\n}\n\nBlockly.Css.register(`\n.categoryBubble {\n  margin: 0 auto 0.125rem;\n  border-radius: 100%;\n  border: 1px solid;\n  width: 1.25rem;\n  height: 1.25rem;\n}\n.blocklyTreeRow {\n  height: initial;\n  padding: 3px 0;\n}\n.blocklyTreeRowContentContainer {\n  display: flex;\n  flex-direction: column;\n}\n.blocklyTreeLabel {\n  margin: auto;\n}\n`)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}