{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n  const s = o.strict;\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? {\n      ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\nclass Ajv {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = {\n      ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n    if (schemaId === \"id\") {\n      _dataRefSchema = {\n        ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n  validate(schemaKeyRef,\n  // key, ref or schema object\n  data // to be validated\n  ) {\n    let v;\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n    async function runCompileAsync(_schema, _meta) {\n      await loadMetaSchema.call(this, _schema.$schema);\n      const sch = this._addSchema(_schema, _meta);\n      return sch.validate || _compileAsync.call(this, sch);\n    }\n    async function loadMetaSchema($ref) {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {\n          $ref\n        }, true);\n      }\n    }\n    async function _compileAsync(sch) {\n      try {\n        return this._compileSchemaEnv(sch);\n      } catch (e) {\n        if (!(e instanceof ref_error_1.default)) throw e;\n        checkLoaded.call(this, e);\n        await loadMissingSchema.call(this, e.missingSchema);\n        return _compileAsync.call(this, sch);\n      }\n    }\n    function checkLoaded(_ref) {\n      let {\n        missingSchema: ref,\n        missingRef\n      } = _ref;\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n    async function loadMissingSchema(ref) {\n      const _schema = await _loadSchema.call(this, ref);\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema);\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n    }\n    async function _loadSchema(ref) {\n      const p = this._loading[ref];\n      if (p) return p;\n      try {\n        return await (this._loading[ref] = loadSchema(ref));\n      } finally {\n        delete this._loading[ref];\n      }\n    }\n  }\n  // Adds schema to the instance\n  addSchema(schema,\n  // If array is passed, `key` will be ignored\n  key,\n  // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta) {\n    let _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n      return this;\n    }\n    let id;\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n    key = (0, resolve_1.normalizeId)(key || id);\n    this._checkUnique(key);\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  }\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(schema, key) {\n    let _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  }\n  //  Validate schema against its meta-schema\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n    const valid = this.validate($schema, schema);\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n    return valid;\n  }\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema(keyRef) {\n    let sch;\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n      return this;\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n          this._cache.delete(cacheKey);\n          let id = schemaKeyRef[this.opts.schemaId];\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n          return this;\n        }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n    return this;\n  }\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n    checkKeyword.call(this, keyword, def);\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n    keywordMetaschema.call(this, def);\n    const definition = {\n      ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  }\n  // Remove keyword\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n    return this;\n  }\n  // Add format\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n  errorsText() {\n    let errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;\n    let {\n      separator = \", \",\n      dataVar = \"data\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n      let keywords = metaSchema;\n      for (const seg of segments) keywords = keywords[seg];\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n    return metaSchema;\n  }\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n  _addSchema(schema, meta, baseId) {\n    let validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n    let addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n    let sch = this._cache.get(schema);\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n    this._cache.set(sch.schema, sch);\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg) {\n  let log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"error\";\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\nfunction getMetaSchemaOptions() {\n  const metaOpts = {\n    ...this.opts\n  };\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n  return metaOpts;\n}\nconst noLogs = {\n  log() {},\n  warn() {},\n  error() {}\n};\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(_ref2 => {\n    let {\n      type: t\n    } = _ref2;\n    return t === dataType;\n  });\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"names":["validate_1","require","Object","defineProperty","exports","enumerable","get","KeywordCxt","codegen_1","_","str","stringify","nil","Name","CodeGen","validation_error_1","ref_error_1","rules_1","compile_1","codegen_2","resolve_1","dataType_1","util_1","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","code","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","MAX_EXPRESSION","requiredOptions","o","s","strict","_optz","_a","optimize","undefined","regExp","_c","_b","uriResolver","_d","default","strictSchema","_f","_e","strictNumbers","_h","_g","strictTypes","_k","_j","strictTuples","_m","_l","strictRequired","_p","_o","loopRequired","_q","loopEnum","_r","meta","_s","messages","_t","inlineRefs","_u","schemaId","_v","addUsedSchema","_w","validateSchema","_x","validateFormats","_y","unicodeRegExp","_z","int32range","_0","Ajv","constructor","opts","arguments","length","schemas","refs","formats","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","logger","getLogger","formatOpt","RULES","getRules","checkOptions","call","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","Error","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_schema","loadMetaSchema","$schema","_compileAsync","$ref","e","checkLoaded","loadMissingSchema","missingSchema","_ref","ref","missingRef","_loadSchema","addSchema","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","warn","message","errorsText","error","keyRef","getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","ValidationError","MissingRefError","checkOpts","options","log","opt","optsSchemas","defs","metaOpts","noLogs","console","KEYWORD_NAME","dataType","post","ruleGroup","find","_ref2","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/core.ts"],"sourcesContent":["export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}