{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nexports.error = {\n  message: _ref => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps\n      }\n    } = _ref;\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n    return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps,\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`;\n  } // TODO change to reference\n};\n\nconst def = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n  code(cxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt);\n    validatePropertyDeps(cxt, propDeps);\n    validateSchemaDeps(cxt, schDeps);\n  }\n};\nfunction splitDependencies(_ref3) {\n  let {\n    schema\n  } = _ref3;\n  const propertyDeps = {};\n  const schemaDeps = {};\n  for (const key in schema) {\n    if (key === \"__proto__\") continue;\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n    deps[key] = schema[key];\n  }\n  return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt) {\n  let propertyDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  if (Object.keys(propertyDeps).length === 0) return;\n  const missing = gen.let(\"missing\");\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop];\n    if (deps.length === 0) continue;\n    const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \")\n    });\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          (0, code_1.checkReportMissingProp)(cxt, depProp);\n        }\n      });\n    } else {\n      gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n      (0, code_1.reportMissingProp)(cxt, missing);\n      gen.else();\n    }\n  }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt) {\n  let schemaDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n  for (const prop in schemaDeps) {\n    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;\n    gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n      const schCxt = cxt.subschema({\n        keyword,\n        schemaProp: prop\n      }, valid);\n      cxt.mergeValidEvaluated(schCxt, valid);\n    }, () => gen.var(valid, true) // TODO var\n    );\n\n    cxt.ok(valid);\n  }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","code_1","exports","error","message","_ref","params","property","depsCount","deps","property_ies","str","_ref2","missingProperty","_","def","keyword","type","schemaType","code","cxt","propDeps","schDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","_ref3","schema","propertyDeps","schemaDeps","key","Array","isArray","arguments","length","undefined","gen","data","it","Object","keys","missing","let","prop","hasProperty","propertyInData","opts","ownProperties","setParams","join","allErrors","if","depProp","checkReportMissingProp","checkMissingProp","reportMissingProp","else","valid","name","alwaysValidSchema","schCxt","subschema","schemaProp","mergeValidEvaluated","var","ok","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}