{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n  let _ValidationError;\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n  try {\n    this._compilations.add(sch);\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize);\n    // gen.optimize(1)\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n  let _sch = resolve.call(this, root, ref);\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root,\n// information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root,\n// root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = this.opts.uriResolver.parse(ref);\n  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n  const id = (0, resolve_1.normalizeId)(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n  return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\nfunction getJsonPointer(parsedRef, _ref) {\n  let {\n    baseId,\n    schema,\n    root\n  } = _ref;\n  var _a;\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return;\n    const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n    if (partSchema === undefined) return;\n    schema = partSchema;\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    }\n  }\n  let env;\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"names":["codegen_1","require","validation_error_1","names_1","resolve_1","util_1","validate_1","SchemaEnv","constructor","env","refs","dynamicAnchors","schema","schemaId","root","baseId","_a","normalizeId","schemaPath","localRefs","meta","$async","exports","compileSchema","sch","_sch","getCompilingSchema","call","rootId","getFullPath","opts","uriResolver","es5","lines","code","ownProperties","gen","CodeGen","scope","_ValidationError","scopeValue","ref","default","_","validateName","scopeName","schemaCxt","allErrors","data","parentData","parentDataProperty","dataNames","dataPathArr","nil","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","stringify","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","validateFunctionCode","optimize","validateCode","toString","scopeRefs","process","makeValidate","Function","validate","get","value","errors","scopeValues","_values","unevaluated","props","items","evaluated","Name","undefined","dynamicProps","dynamicItems","e","logger","error","delete","resolveRef","resolveUrl","schOrFunc","resolve","inlineOrCompile","inlineRef","inlineRefs","schEnv","sameSchemaEnv","s1","s2","schemas","resolveSchema","p","parse","refPath","_getFullPath","Object","keys","length","getJsonPointer","id","schOrRef","schId","PREVENT_SCOPE_CHANGE","parsedRef","_ref","fragment","part","slice","split","partSchema","unescapeFragment","has","$ref","schemaHasRulesButRef","RULES"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/compile/index.ts"],"sourcesContent":["import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport * as URI from \"uri-js\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URI.URIComponents,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}