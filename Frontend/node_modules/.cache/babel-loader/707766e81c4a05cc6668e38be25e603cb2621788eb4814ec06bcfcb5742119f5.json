{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must have required property '${missingProperty}'`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{missingProperty: ${missingProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      schemaCode,\n      data,\n      $data,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    if (!$data && schema.length === 0) return;\n    const useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties;\n      const {\n        definedProperties\n      } = cxt.it;\n      for (const requiredKey of schema) {\n        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n          (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n        }\n      }\n    }\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        for (const prop of schema) {\n          (0, code_1.checkReportMissingProp)(cxt, prop);\n        }\n      }\n    }\n    function exitOnErrorMode() {\n      const missing = gen.let(\"missing\");\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, prop => {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n      });\n    }\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, () => {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), () => {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["code_1","require","codegen_1","util_1","error","message","_ref","params","missingProperty","str","_ref2","_","def","keyword","type","schemaType","$data","code","cxt","gen","schema","schemaCode","data","it","opts","length","useLoop","loopRequired","allErrors","allErrorsMode","exitOnErrorMode","strictRequired","props","parentSchema","properties","definedProperties","requiredKey","undefined","has","schemaPath","schemaEnv","baseId","errSchemaPath","msg","checkStrictMode","block$data","nil","loopAllRequired","prop","checkReportMissingProp","missing","let","valid","loopUntilMissing","ok","if","checkMissingProp","reportMissingProp","else","forOf","setParams","noPropertyInData","ownProperties","assign","propertyInData","not","break","exports","default"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/validation/required.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;AAEA,MAAAA,MAAA,GAAAC,OAAA;AAOA,MAAAC,SAAA,GAAAD,OAAA;AACA,MAAAE,MAAA,GAAAF,OAAA;AAQA,MAAMG,KAAK,GAA2B;EACpCC,OAAO,EAAEC,IAAA;IAAA,IAAC;MAACC,MAAM,EAAE;QAACC;MAAe;IAAC,CAAC,GAAAF,IAAA;IAAA,OAAK,IAAAJ,SAAA,CAAAO,GAAG,iCAAgCD,eAAe,GAAG;EAAA;EAC/FD,MAAM,EAAEG,KAAA;IAAA,IAAC;MAACH,MAAM,EAAE;QAACC;MAAe;IAAC,CAAC,GAAAE,KAAA;IAAA,OAAK,IAAAR,SAAA,CAAAS,CAAC,sBAAqBH,eAAe,GAAG;EAAA;CAClF;AAED,MAAMI,GAAG,GAA0B;EACjCC,OAAO,EAAE,UAAU;EACnBC,IAAI,EAAE,QAAQ;EACdC,UAAU,EAAE,OAAO;EACnBC,KAAK,EAAE,IAAI;EACXZ,KAAK;EACLa,IAAIA,CAACC,GAAe;IAClB,MAAM;MAACC,GAAG;MAAEC,MAAM;MAAEC,UAAU;MAAEC,IAAI;MAAEN,KAAK;MAAEO;IAAE,CAAC,GAAGL,GAAG;IACtD,MAAM;MAACM;IAAI,CAAC,GAAGD,EAAE;IACjB,IAAI,CAACP,KAAK,IAAII,MAAM,CAACK,MAAM,KAAK,CAAC,EAAE;IACnC,MAAMC,OAAO,GAAGN,MAAM,CAACK,MAAM,IAAID,IAAI,CAACG,YAAY;IAClD,IAAIJ,EAAE,CAACK,SAAS,EAAEC,aAAa,EAAE,MAC5BC,eAAe,EAAE;IAEtB,IAAIN,IAAI,CAACO,cAAc,EAAE;MACvB,MAAMC,KAAK,GAAGd,GAAG,CAACe,YAAY,CAACC,UAAU;MACzC,MAAM;QAACC;MAAiB,CAAC,GAAGjB,GAAG,CAACK,EAAE;MAClC,KAAK,MAAMa,WAAW,IAAIhB,MAAM,EAAE;QAChC,IAAI,CAAAY,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAGI,WAAW,CAAC,MAAKC,SAAS,IAAI,CAACF,iBAAiB,CAACG,GAAG,CAACF,WAAW,CAAC,EAAE;UAC7E,MAAMG,UAAU,GAAGhB,EAAE,CAACiB,SAAS,CAACC,MAAM,GAAGlB,EAAE,CAACmB,aAAa;UACzD,MAAMC,GAAG,GAAG,sBAAsBP,WAAW,wBAAwBG,UAAU,oBAAoB;UACnG,IAAApC,MAAA,CAAAyC,eAAe,EAACrB,EAAE,EAAEoB,GAAG,EAAEpB,EAAE,CAACC,IAAI,CAACO,cAAc,CAAC;;;;IAKtD,SAASF,aAAaA,CAAA;MACpB,IAAIH,OAAO,IAAIV,KAAK,EAAE;QACpBE,GAAG,CAAC2B,UAAU,CAAC3C,SAAA,CAAA4C,GAAG,EAAEC,eAAe,CAAC;OACrC,MAAM;QACL,KAAK,MAAMC,IAAI,IAAI5B,MAAM,EAAE;UACzB,IAAApB,MAAA,CAAAiD,sBAAsB,EAAC/B,GAAG,EAAE8B,IAAI,CAAC;;;IAGvC;IAEA,SAASlB,eAAeA,CAAA;MACtB,MAAMoB,OAAO,GAAG/B,GAAG,CAACgC,GAAG,CAAC,SAAS,CAAC;MAClC,IAAIzB,OAAO,IAAIV,KAAK,EAAE;QACpB,MAAMoC,KAAK,GAAGjC,GAAG,CAACgC,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC;QACpCjC,GAAG,CAAC2B,UAAU,CAACO,KAAK,EAAE,MAAMC,gBAAgB,CAACH,OAAO,EAAEE,KAAK,CAAC,CAAC;QAC7DlC,GAAG,CAACoC,EAAE,CAACF,KAAK,CAAC;OACd,MAAM;QACLjC,GAAG,CAACoC,EAAE,CAAC,IAAAvD,MAAA,CAAAwD,gBAAgB,EAACtC,GAAG,EAAEE,MAAM,EAAE8B,OAAO,CAAC,CAAC;QAC9C,IAAAlD,MAAA,CAAAyD,iBAAiB,EAACvC,GAAG,EAAEgC,OAAO,CAAC;QAC/B/B,GAAG,CAACuC,IAAI,EAAE;;IAEd;IAEA,SAASX,eAAeA,CAAA;MACtB5B,GAAG,CAACwC,KAAK,CAAC,MAAM,EAAEtC,UAAkB,EAAG2B,IAAI,IAAI;QAC7C9B,GAAG,CAAC0C,SAAS,CAAC;UAACpD,eAAe,EAAEwC;QAAI,CAAC,CAAC;QACtC7B,GAAG,CAACoC,EAAE,CAAC,IAAAvD,MAAA,CAAA6D,gBAAgB,EAAC1C,GAAG,EAAEG,IAAI,EAAE0B,IAAI,EAAExB,IAAI,CAACsC,aAAa,CAAC,EAAE,MAAM5C,GAAG,CAACd,KAAK,EAAE,CAAC;MAClF,CAAC,CAAC;IACJ;IAEA,SAASiD,gBAAgBA,CAACH,OAAa,EAAEE,KAAW;MAClDlC,GAAG,CAAC0C,SAAS,CAAC;QAACpD,eAAe,EAAE0C;MAAO,CAAC,CAAC;MACzC/B,GAAG,CAACwC,KAAK,CACPT,OAAO,EACP7B,UAAkB,EAClB,MAAK;QACHF,GAAG,CAAC4C,MAAM,CAACX,KAAK,EAAE,IAAApD,MAAA,CAAAgE,cAAc,EAAC7C,GAAG,EAAEG,IAAI,EAAE4B,OAAO,EAAE1B,IAAI,CAACsC,aAAa,CAAC,CAAC;QACzE3C,GAAG,CAACoC,EAAE,CAAC,IAAArD,SAAA,CAAA+D,GAAG,EAACb,KAAK,CAAC,EAAE,MAAK;UACtBlC,GAAG,CAACd,KAAK,EAAE;UACXe,GAAG,CAAC+C,KAAK,EAAE;QACb,CAAC,CAAC;MACJ,CAAC,EACDhE,SAAA,CAAA4C,GAAG,CACJ;IACH;EACF;CACD;AAEDqB,OAAA,CAAAC,OAAA,GAAexD,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}