{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n  message: \"must be equal to one of the allowed values\",\n  params: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1._)`{allowedValues: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    const useLoop = schema.length >= it.opts.loopEnum;\n    let eql;\n    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n    let valid;\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      const vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, v => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n    }\n    function equalCode(vSchema, i) {\n      const sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"names":["codegen_1","require","util_1","equal_1","error","message","params","_ref","schemaCode","_","def","keyword","schemaType","$data","code","cxt","gen","data","schema","it","length","Error","useLoop","opts","loopEnum","eql","getEql","useFunc","default","valid","let","block$data","Array","isArray","vSchema","const","or","map","_x","i","equalCode","pass","assign","forOf","v","if","break","sch","exports"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/vocabularies/validation/enum.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n"],"mappings":";;;;;AAEA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,MAAA,GAAAD,OAAA;AACA,MAAAE,OAAA,GAAAF,OAAA;AAIA,MAAMG,KAAK,GAA2B;EACpCC,OAAO,EAAE,4CAA4C;EACrDC,MAAM,EAAEC,IAAA;IAAA,IAAC;MAACC;IAAU,CAAC,GAAAD,IAAA;IAAA,OAAK,IAAAP,SAAA,CAAAS,CAAC,oBAAmBD,UAAU,GAAG;EAAA;CAC5D;AAED,MAAME,GAAG,GAA0B;EACjCC,OAAO,EAAE,MAAM;EACfC,UAAU,EAAE,OAAO;EACnBC,KAAK,EAAE,IAAI;EACXT,KAAK;EACLU,IAAIA,CAACC,GAAe;IAClB,MAAM;MAACC,GAAG;MAAEC,IAAI;MAAEJ,KAAK;MAAEK,MAAM;MAAEV,UAAU;MAAEW;IAAE,CAAC,GAAGJ,GAAG;IACtD,IAAI,CAACF,KAAK,IAAIK,MAAM,CAACE,MAAM,KAAK,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACpF,MAAMC,OAAO,GAAGJ,MAAM,CAACE,MAAM,IAAID,EAAE,CAACI,IAAI,CAACC,QAAQ;IACjD,IAAIC,GAAqB;IACzB,MAAMC,MAAM,GAAGA,CAAA,KAAaD,GAAG,aAAHA,GAAG,cAAHA,GAAG,GAAHA,GAAG,GAAK,IAAAvB,MAAA,CAAAyB,OAAO,EAACX,GAAG,EAAEb,OAAA,CAAAyB,OAAK,CAAE;IAExD,IAAIC,KAAW;IACf,IAAIP,OAAO,IAAIT,KAAK,EAAE;MACpBgB,KAAK,GAAGb,GAAG,CAACc,GAAG,CAAC,OAAO,CAAC;MACxBf,GAAG,CAACgB,UAAU,CAACF,KAAK,EAAEL,QAAQ,CAAC;KAChC,MAAM;MACL;MACA,IAAI,CAACQ,KAAK,CAACC,OAAO,CAACf,MAAM,CAAC,EAAE,MAAM,IAAIG,KAAK,CAAC,0BAA0B,CAAC;MACvE,MAAMa,OAAO,GAAGlB,GAAG,CAACmB,KAAK,CAAC,SAAS,EAAE3B,UAAU,CAAC;MAChDqB,KAAK,GAAG,IAAA7B,SAAA,CAAAoC,EAAE,EAAC,GAAGlB,MAAM,CAACmB,GAAG,CAAC,CAACC,EAAW,EAAEC,CAAS,KAAKC,SAAS,CAACN,OAAO,EAAEK,CAAC,CAAC,CAAC,CAAC;;IAE9ExB,GAAG,CAAC0B,IAAI,CAACZ,KAAK,CAAC;IAEf,SAASL,QAAQA,CAAA;MACfR,GAAG,CAAC0B,MAAM,CAACb,KAAK,EAAE,KAAK,CAAC;MACxBb,GAAG,CAAC2B,KAAK,CAAC,GAAG,EAAEnC,UAAkB,EAAGoC,CAAC,IACnC5B,GAAG,CAAC6B,EAAE,CAAC,IAAA7C,SAAA,CAAAS,CAAC,IAAGiB,MAAM,EAAE,IAAIT,IAAI,KAAK2B,CAAC,GAAG,EAAE,MAAM5B,GAAG,CAAC0B,MAAM,CAACb,KAAK,EAAE,IAAI,CAAC,CAACiB,KAAK,EAAE,CAAC,CAC7E;IACH;IAEA,SAASN,SAASA,CAACN,OAAa,EAAEK,CAAS;MACzC,MAAMQ,GAAG,GAAG7B,MAAM,CAACqB,CAAC,CAAC;MACrB,OAAO,OAAOQ,GAAG,KAAK,QAAQ,IAAIA,GAAG,KAAK,IAAI,GAC1C,IAAA/C,SAAA,CAAAS,CAAC,IAAGiB,MAAM,EAAE,IAAIT,IAAI,KAAKiB,OAAO,IAAIK,CAAC,IAAI,GACzC,IAAAvC,SAAA,CAAAS,CAAC,IAAGQ,IAAI,QAAQ8B,GAAG,EAAE;IAC3B;EACF;CACD;AAEDC,OAAA,CAAApB,OAAA,GAAelB,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}