{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\nfunction inlineRef(schema) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n  return false;\n}\nfunction countKeys(schema) {\n  let count = 0;\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], sch => count += countKeys(sch));\n    }\n    if (count === Infinity) return Infinity;\n  }\n  return count;\n}\nfunction getFullPath(resolver) {\n  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let normalize = arguments.length > 2 ? arguments[2] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  const p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n  const serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n  if (typeof schema == \"boolean\") return {};\n  const {\n    schemaId,\n    uriResolver\n  } = this.opts;\n  const schId = normalizeId(schema[schemaId] || baseId);\n  const baseIds = {\n    \"\": schId\n  };\n  const pathPrefix = getFullPath(uriResolver, schId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n      return ref;\n    }\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"names":["util_1","require","equal","traverse","SIMPLE_INLINED","Set","inlineRef","schema","limit","arguments","length","undefined","hasRef","countKeys","exports","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","eachItem","getFullPath","resolver","id","normalize","normalizeId","p","parse","_getFullPath","serialized","serialize","split","TRAILING_SLASH_HASH","replace","resolveUrl","baseId","resolve","ANCHOR","getSchemaRefs","schemaId","uriResolver","opts","schId","baseIds","pathPrefix","localRefs","schemaRefs","allKeys","jsonPtr","_","parentJsonPtr","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","_resolve","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/node_modules/ajv/lib/compile/resolve.ts"],"sourcesContent":["import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}