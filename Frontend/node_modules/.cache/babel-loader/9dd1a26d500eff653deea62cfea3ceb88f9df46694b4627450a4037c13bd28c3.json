{"ast":null,"code":"import { TAB_HEIGHT } from '../components/blockly/custom/CustomConstantProvider';\nimport Blockly from 'blockly/core';\nimport { blocksList } from '../constants';\nimport { parseBlockData } from '../context/util';\nconst ANIMATION_DURATION = 500;\nexport class AutoChainService {\n  constructor(workspace, autoChainResponse) {\n    this.workspace = void 0;\n    this.chainData = void 0;\n    this.blocksById = {};\n    /**\n     * Find the blocks that are to be connected to the given block\n     * @param blockData - The block data\n     * @returns - The blocks that reference the given block\n     */\n    this.findReferencingBlocks = blockData => {\n      const referencingBlocks = [];\n      for (const otherBlockData of this.chainData.chain) {\n        if (otherBlockData.inputs && Object.values(otherBlockData.inputs).includes(blockData.id)) {\n          referencingBlocks.push(otherBlockData);\n        }\n      }\n      return referencingBlocks;\n    };\n    this.removeHighlight = blocks => {\n      blocks.forEach(block => block.removeSelect());\n    };\n    this.workspace = workspace;\n    this.chainData = autoChainResponse;\n  }\n\n  /**\n   * Get the left most blocks (root blocks) in the chain. The left most blocks are the blocks that have no inputs.\n   * @returns Descending ordered array of the root blocks based on the length of their longest path\n   */\n  getRootBlocks() {\n    const findBlockPathLength = blockData => {\n      if (!blockData.inputs) {\n        return [blockData];\n      }\n      const inputBlockData = this.chainData.chain.find(block => block.id === Object.values(blockData.inputs)[0]);\n      return [blockData, ...findBlockPathLength(inputBlockData)];\n    };\n    const rootBlocks = [];\n    for (const blockData of this.chainData.chain) {\n      if (!blockData.inputs) {\n        rootBlocks.push(blockData);\n      }\n    }\n    rootBlocks.sort((a, b) => findBlockPathLength(b).length - findBlockPathLength(a).length);\n    return rootBlocks;\n  }\n  prepareWorkspace() {\n    // change scale to 0.5 to fit more blocks in the workspace\n    this.workspace.setScale(0.5);\n  }\n\n  /**\n   * Gets the block definition for the given block data.\n   * Input blocks are special case. They have different names in the block list and in the autochain response\n   * @param blockData\n   */\n  getBlockDefinition(blockData) {\n    let blockDefinition;\n    if (blockData.type.includes('input')) {\n      switch (blockData.type) {\n        case 'text_input':\n          blockDefinition = blocksList.find(block => block.name === 'Write input');\n          break;\n        case 'image_input':\n          blockDefinition = blocksList.find(block => block.name === 'Upload image');\n          break;\n        case 'video_input':\n          blockDefinition = blocksList.find(block => block.name === 'Upload video');\n          break;\n        case 'audio_input':\n          blockDefinition = blocksList.find(block => block.name === 'Upload audio');\n          break;\n        case '3d_input':\n          blockDefinition = blocksList.find(block => block.name === 'Upload 3D model');\n          break;\n        case 'sketch_input':\n          blockDefinition = blocksList.find(block => block.name === 'Draw doodle');\n          break;\n        case 'custom_input':\n          blockDefinition = blocksList.find(block => block.name === 'Custom');\n          break;\n      }\n    } else {\n      blockDefinition = blocksList.find(block => block.endpointName === blockData.type);\n    }\n    return blockDefinition;\n  }\n\n  /**\n   * Create a block in the workspace\n   * @param blockData - The block data\n   * @param isRoot - Whether the block is a root block (left most block with longest path in the chain)\n   */\n  addBlock(blockData) {\n    var _this$chainData$param;\n    let isRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.blocksById[blockData.id]) {\n      return;\n    }\n\n    // The autochain response uses the endpoint name as the block type\n    const blockDefinition = this.getBlockDefinition(blockData);\n    if (!blockDefinition) {\n      throw new Error(`Block definition for ${blockData.type} not found`);\n    }\n    const block = this.workspace.newBlock(blockDefinition.name);\n    const model = (_this$chainData$param = this.chainData.parameters[blockData.id]) !== null && _this$chainData$param !== void 0 ? _this$chainData$param : {};\n    /**\n     * Keep track of the parameters of each block so that we can use them when processing the chain\n     */\n    block.data = JSON.stringify({\n      ...parseBlockData(block.data || ''),\n      model: model\n    });\n\n    // All blocks other than root should be positiond somewhere far away from current blocks\n    // otherwise it might be positioned on top of another block, which would cause the existing\n    // block to be moved\n    if (!isRoot) {\n      block.moveBy(1000000, 0);\n    }\n    block.initSvg();\n    block.render();\n\n    // To start the chain from the middle of the workspace\n    if (isRoot) {\n      var _this$workspace$getTo, _this$workspace$getTo2;\n      const metrics = this.workspace.getMetrics();\n      const toolboxHeight = (_this$workspace$getTo = (_this$workspace$getTo2 = this.workspace.getToolbox()) === null || _this$workspace$getTo2 === void 0 ? void 0 : _this$workspace$getTo2.getHeight()) !== null && _this$workspace$getTo !== void 0 ? _this$workspace$getTo : 0;\n      block.translate(block.getRelativeToSurfaceXY().x, metrics.viewTop + toolboxHeight - block.height / 2);\n\n      // assuming all blocks are of the same size\n      const blockSize = block.getHeightWidth();\n      const blockPosition = block.getRelativeToSurfaceXY();\n      const chainSize = {\n        width: blockSize.width * this.chainData.chain.length,\n        height: blockSize.height\n      };\n\n      // move the camera to show the chain at the center\n      this.workspace.scroll(blockPosition.x + chainSize.width / 2, blockPosition.y - toolboxHeight);\n    }\n    this.workspace.fireChangeListener(new Blockly.Events.BlockCreate());\n    this.blocksById[blockData.id] = block;\n  }\n  /**\n   * Translate the block to the position of the connection it is being connected to\n   * @param parentBlock - The block that is being connected to\n   * @param nextBlock - The block that is being connected\n   * @param nextBlockInputConnection - The connection of the block that is being connected\n   */\n  translateBlock(parentBlock, nextBlock, nextBlockInputConnection) {\n    let spaceFromBlockTopToConnection = 0;\n\n    // If a block has more than one input, we should find the position of the comparison input\n    // The block, when added to the workspace, is positioned at the top left corner of the block\n    // So move the block down by the height of the block to get the position of the comparison input\n    if (nextBlock.inputList.length > 1) {\n      var _topConnection2;\n      let topConnection = nextBlock.inputList[0].connection;\n      nextBlock.inputList.forEach(input => {\n        var _input$connection$y, _input$connection, _topConnection$y, _topConnection;\n        if (((_input$connection$y = (_input$connection = input.connection) === null || _input$connection === void 0 ? void 0 : _input$connection.y) !== null && _input$connection$y !== void 0 ? _input$connection$y : 0) < ((_topConnection$y = (_topConnection = topConnection) === null || _topConnection === void 0 ? void 0 : _topConnection.y) !== null && _topConnection$y !== void 0 ? _topConnection$y : 0)) {\n          topConnection = input.connection;\n        }\n      });\n      if (((_topConnection2 = topConnection) === null || _topConnection2 === void 0 ? void 0 : _topConnection2.y) !== nextBlockInputConnection.y) {\n        // 3.15 is found by trial and error\n        spaceFromBlockTopToConnection = TAB_HEIGHT * 3.2;\n      }\n    }\n    const {\n      x,\n      y\n    } = parentBlock.getRelativeToSurfaceXY();\n    nextBlock.translate(x + nextBlock.getHeightWidth().width - TAB_HEIGHT, y - spaceFromBlockTopToConnection);\n  }\n\n  /**\n   * Highlight parent and next block for animation\n   * @param block - The block to be highlighted\n   * @param alreadyHighlighted\n   */\n  highlightBlock(block, alreadyHighlighted) {\n    // The root block should not be highlighted\n    if (!alreadyHighlighted.has(block.id)) {\n      block.addSelect();\n      alreadyHighlighted.add(block.id);\n    }\n  }\n  /**\n   * Chain the given block to its referencing blocks\n   * @param blockData - The block data\n   * @param alreadyHighlighted - The blocks that have already been highlighted\n   * @param isRoot - Whether the block is a root block (left most block with longest path in the chain)\n   */\n  async chainBlock(blockData) {\n    let alreadyHighlighted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n    let isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.addBlock(blockData, isRoot);\n    const referencingBlocks = this.findReferencingBlocks(blockData);\n    const parentBlock = this.blocksById[blockData.id];\n\n    // Required to animate first connection of the root block\n    if (isRoot) {\n      await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION));\n    }\n    for (const refBlock of referencingBlocks) {\n      var _nextBlock$getInput;\n      const alreadyAdded = !!this.blocksById[refBlock.id];\n      this.addBlock(refBlock);\n\n      // Next block to be connected to the parent block\n      const nextBlock = this.blocksById[refBlock.id];\n      const parentOutputConnection = parentBlock.outputConnection;\n      const inputKey = Object.keys(refBlock.inputs).find(key => refBlock.inputs[key] === blockData.id);\n      const nextBlockInputConnection = (_nextBlock$getInput = nextBlock.getInput(inputKey)) === null || _nextBlock$getInput === void 0 ? void 0 : _nextBlock$getInput.connection;\n      if (nextBlockInputConnection && parentOutputConnection) {\n        // Due to the recursive nature of the function, the next block may have already been connected\n        // To avoid moving the block twice, we check if the block has already been added\n        if (!alreadyAdded) {\n          this.translateBlock(parentBlock, nextBlock, nextBlockInputConnection);\n        }\n\n        // The root block should not be highlighted\n        if (!isRoot) {\n          this.highlightBlock(parentBlock, alreadyHighlighted);\n        }\n        this.highlightBlock(nextBlock, alreadyHighlighted);\n        nextBlockInputConnection.connect(parentOutputConnection);\n        // For animation\n        await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION));\n        this.removeHighlight([parentBlock, nextBlock]);\n      }\n    }\n\n    // Chain the referencing blocks\n    for (const refBlock of referencingBlocks) {\n      await this.chainBlock(refBlock, alreadyHighlighted);\n    }\n  }\n\n  /**\n   * Automatically chain the blocks in the workspace\n   */\n  async autoChain() {\n    const rootBlocks = this.getRootBlocks();\n\n    // A valid chain must have at least one root block\n    if (!rootBlocks.length) {\n      throw Error('No root blocks found');\n    }\n\n    // Keep track of the blocks that have been highlighted\n    // so that they are not highlighted again when they are connected\n    const alreadyHighlightedBlocks = new Set();\n    this.prepareWorkspace();\n    for (const [i, leftMostBlock] of rootBlocks.entries()) {\n      // The first block is the root block (since rootBlocks are sorted by their path length)\n      const isRoot = i === 0;\n      await this.chainBlock(leftMostBlock, alreadyHighlightedBlocks, isRoot);\n    }\n  }\n}","map":{"version":3,"names":["TAB_HEIGHT","Blockly","blocksList","parseBlockData","ANIMATION_DURATION","AutoChainService","constructor","workspace","autoChainResponse","chainData","blocksById","findReferencingBlocks","blockData","referencingBlocks","otherBlockData","chain","inputs","Object","values","includes","id","push","removeHighlight","blocks","forEach","block","removeSelect","getRootBlocks","findBlockPathLength","inputBlockData","find","rootBlocks","sort","a","b","length","prepareWorkspace","setScale","getBlockDefinition","blockDefinition","type","name","endpointName","addBlock","_this$chainData$param","isRoot","arguments","undefined","Error","newBlock","model","parameters","data","JSON","stringify","moveBy","initSvg","render","_this$workspace$getTo","_this$workspace$getTo2","metrics","getMetrics","toolboxHeight","getToolbox","getHeight","translate","getRelativeToSurfaceXY","x","viewTop","height","blockSize","getHeightWidth","blockPosition","chainSize","width","scroll","y","fireChangeListener","Events","BlockCreate","translateBlock","parentBlock","nextBlock","nextBlockInputConnection","spaceFromBlockTopToConnection","inputList","_topConnection2","topConnection","connection","input","_input$connection$y","_input$connection","_topConnection$y","_topConnection","highlightBlock","alreadyHighlighted","has","addSelect","add","chainBlock","Set","Promise","resolve","setTimeout","refBlock","_nextBlock$getInput","alreadyAdded","parentOutputConnection","outputConnection","inputKey","keys","key","getInput","connect","autoChain","alreadyHighlightedBlocks","i","leftMostBlock","entries"],"sources":["/Users/chuanenl/MyDrive/CMU/Projects/Jigsaw/Code/Frontend/src/service/autochain.service.ts"],"sourcesContent":["import { TAB_HEIGHT } from '../components/blockly/custom/CustomConstantProvider'\nimport { BlockParameters } from '../types'\nimport Blockly, { Connection } from 'blockly/core'\nimport { blocksList, EndpointToBlockType } from '../constants'\nimport { parseBlockData } from '../context/util'\n\nexport interface AutoChainBlock {\n  id: string\n  type: string\n  inputs?: { [key: string]: string }\n}\n\nexport type AutoChainData = {\n  chain: Array<AutoChainBlock>\n  parameters: { [key: string]: Pick<BlockParameters, 'model'> }\n}\n\nconst ANIMATION_DURATION = 500\n\nexport class AutoChainService {\n  private workspace: Blockly.WorkspaceSvg\n  private chainData: AutoChainData\n  private blocksById: { [key: string]: Blockly.BlockSvg } = {}\n\n  constructor(workspace: Blockly.WorkspaceSvg, autoChainResponse: AutoChainData) {\n    this.workspace = workspace\n    this.chainData = autoChainResponse\n  }\n\n  /**\n   * Get the left most blocks (root blocks) in the chain. The left most blocks are the blocks that have no inputs.\n   * @returns Descending ordered array of the root blocks based on the length of their longest path\n   */\n  getRootBlocks() {\n    const findBlockPathLength = (blockData: AutoChainBlock): AutoChainBlock[] => {\n      if (!blockData.inputs) {\n        return [blockData]\n      }\n\n      const inputBlockData = this.chainData.chain.find(\n        (block) => block.id === Object.values(blockData.inputs!)[0],\n      )!\n\n      return [blockData, ...findBlockPathLength(inputBlockData)]\n    }\n\n    const rootBlocks: AutoChainBlock[] = []\n\n    for (const blockData of this.chainData.chain) {\n      if (!blockData.inputs) {\n        rootBlocks.push(blockData)\n      }\n    }\n\n    rootBlocks.sort((a, b) => findBlockPathLength(b).length - findBlockPathLength(a).length)\n\n    return rootBlocks\n  }\n\n  prepareWorkspace() {\n    // change scale to 0.5 to fit more blocks in the workspace\n    this.workspace.setScale(0.5)\n  }\n\n  /**\n   * Gets the block definition for the given block data.\n   * Input blocks are special case. They have different names in the block list and in the autochain response\n   * @param blockData\n   */\n  getBlockDefinition(blockData: AutoChainBlock) {\n    let blockDefinition\n    if (blockData.type.includes('input')) {\n      switch (blockData.type) {\n        case 'text_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Write input')\n          break\n        case 'image_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Upload image')\n          break\n        case 'video_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Upload video')\n          break\n        case 'audio_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Upload audio')\n          break\n        case '3d_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Upload 3D model')\n          break\n        case 'sketch_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Draw doodle')\n          break\n        case 'custom_input':\n          blockDefinition = blocksList.find((block) => block.name === 'Custom')\n          break\n      }\n    } else {\n      blockDefinition = blocksList.find((block) => block.endpointName === blockData.type)\n    }\n\n    return blockDefinition\n  }\n\n  /**\n   * Create a block in the workspace\n   * @param blockData - The block data\n   * @param isRoot - Whether the block is a root block (left most block with longest path in the chain)\n   */\n  addBlock(blockData: AutoChainBlock, isRoot = false) {\n    if (this.blocksById[blockData.id]) {\n      return\n    }\n\n    // The autochain response uses the endpoint name as the block type\n    const blockDefinition = this.getBlockDefinition(blockData)\n\n    if (!blockDefinition) {\n      throw new Error(`Block definition for ${blockData.type} not found`)\n    }\n\n    const block = this.workspace.newBlock(blockDefinition.name)\n    const model = this.chainData.parameters[blockData.id] ?? {}\n    /**\n     * Keep track of the parameters of each block so that we can use them when processing the chain\n     */\n    block.data = JSON.stringify({\n      ...parseBlockData(block.data || ''),\n      model: model,\n    })\n\n    // All blocks other than root should be positiond somewhere far away from current blocks\n    // otherwise it might be positioned on top of another block, which would cause the existing\n    // block to be moved\n    if (!isRoot) {\n      block.moveBy(1000000, 0)\n    }\n\n    block.initSvg()\n    block.render()\n\n    // To start the chain from the middle of the workspace\n    if (isRoot) {\n      const metrics = this.workspace.getMetrics()\n      const toolboxHeight = this.workspace.getToolbox()?.getHeight() ?? 0\n\n      block.translate(\n        block.getRelativeToSurfaceXY().x,\n        metrics.viewTop + toolboxHeight - block.height / 2,\n      )\n\n      // assuming all blocks are of the same size\n      const blockSize = block.getHeightWidth()\n      const blockPosition = block.getRelativeToSurfaceXY()\n      const chainSize = {\n        width: blockSize.width * this.chainData.chain.length,\n        height: blockSize.height,\n      }\n\n      // move the camera to show the chain at the center\n      this.workspace.scroll(blockPosition.x + chainSize.width / 2, blockPosition.y - toolboxHeight)\n    }\n\n    this.workspace.fireChangeListener(new Blockly.Events.BlockCreate())\n    this.blocksById[blockData.id] = block\n  }\n\n  /**\n   * Find the blocks that are to be connected to the given block\n   * @param blockData - The block data\n   * @returns - The blocks that reference the given block\n   */\n  findReferencingBlocks = (blockData: AutoChainBlock) => {\n    const referencingBlocks: AutoChainBlock[] = []\n\n    for (const otherBlockData of this.chainData.chain) {\n      if (otherBlockData.inputs && Object.values(otherBlockData.inputs).includes(blockData.id)) {\n        referencingBlocks.push(otherBlockData)\n      }\n    }\n\n    return referencingBlocks\n  }\n\n  /**\n   * Translate the block to the position of the connection it is being connected to\n   * @param parentBlock - The block that is being connected to\n   * @param nextBlock - The block that is being connected\n   * @param nextBlockInputConnection - The connection of the block that is being connected\n   */\n  translateBlock(\n    parentBlock: Blockly.BlockSvg,\n    nextBlock: Blockly.BlockSvg,\n    nextBlockInputConnection: Connection,\n  ) {\n    let spaceFromBlockTopToConnection = 0\n\n    // If a block has more than one input, we should find the position of the comparison input\n    // The block, when added to the workspace, is positioned at the top left corner of the block\n    // So move the block down by the height of the block to get the position of the comparison input\n    if (nextBlock.inputList.length > 1) {\n      let topConnection = nextBlock.inputList[0].connection\n      nextBlock.inputList.forEach((input) => {\n        if ((input.connection?.y ?? 0) < (topConnection?.y ?? 0)) {\n          topConnection = input.connection\n        }\n      })\n\n      if (topConnection?.y !== nextBlockInputConnection.y) {\n        // 3.15 is found by trial and error\n        spaceFromBlockTopToConnection = TAB_HEIGHT * 3.2\n      }\n    }\n\n    const { x, y } = parentBlock.getRelativeToSurfaceXY()\n    nextBlock.translate(\n      x + nextBlock.getHeightWidth().width - TAB_HEIGHT,\n      y - spaceFromBlockTopToConnection,\n    )\n  }\n\n  /**\n   * Highlight parent and next block for animation\n   * @param block - The block to be highlighted\n   * @param alreadyHighlighted\n   */\n  highlightBlock(block: Blockly.BlockSvg, alreadyHighlighted: Set<string>) {\n    // The root block should not be highlighted\n    if (!alreadyHighlighted.has(block.id)) {\n      block.addSelect()\n      alreadyHighlighted.add(block.id)\n    }\n  }\n\n  removeHighlight = (blocks: Blockly.BlockSvg[]) => {\n    blocks.forEach((block) => block.removeSelect())\n  }\n\n  /**\n   * Chain the given block to its referencing blocks\n   * @param blockData - The block data\n   * @param alreadyHighlighted - The blocks that have already been highlighted\n   * @param isRoot - Whether the block is a root block (left most block with longest path in the chain)\n   */\n  async chainBlock(\n    blockData: AutoChainBlock,\n    alreadyHighlighted: Set<string> = new Set<string>(),\n    isRoot = false,\n  ) {\n    this.addBlock(blockData, isRoot)\n\n    const referencingBlocks = this.findReferencingBlocks(blockData)\n    const parentBlock = this.blocksById[blockData.id]\n\n    // Required to animate first connection of the root block\n    if (isRoot) {\n      await new Promise((resolve) => setTimeout(resolve, ANIMATION_DURATION))\n    }\n\n    for (const refBlock of referencingBlocks) {\n      const alreadyAdded = !!this.blocksById[refBlock.id]\n      this.addBlock(refBlock)\n\n      // Next block to be connected to the parent block\n      const nextBlock = this.blocksById[refBlock.id]\n\n      const parentOutputConnection = parentBlock.outputConnection\n      const inputKey = Object.keys(refBlock.inputs!).find(\n        (key) => refBlock.inputs![key] === blockData.id,\n      )\n      const nextBlockInputConnection = nextBlock.getInput(inputKey!)?.connection\n\n      if (nextBlockInputConnection && parentOutputConnection) {\n        // Due to the recursive nature of the function, the next block may have already been connected\n        // To avoid moving the block twice, we check if the block has already been added\n        if (!alreadyAdded) {\n          this.translateBlock(parentBlock, nextBlock, nextBlockInputConnection)\n        }\n\n        // The root block should not be highlighted\n        if (!isRoot) {\n          this.highlightBlock(parentBlock, alreadyHighlighted)\n        }\n\n        this.highlightBlock(nextBlock, alreadyHighlighted)\n\n        nextBlockInputConnection.connect(parentOutputConnection)\n        // For animation\n        await new Promise((resolve) => setTimeout(resolve, ANIMATION_DURATION))\n\n        this.removeHighlight([parentBlock, nextBlock])\n      }\n    }\n\n    // Chain the referencing blocks\n    for (const refBlock of referencingBlocks) {\n      await this.chainBlock(refBlock, alreadyHighlighted)\n    }\n  }\n\n  /**\n   * Automatically chain the blocks in the workspace\n   */\n  async autoChain() {\n    const rootBlocks = this.getRootBlocks()\n\n    // A valid chain must have at least one root block\n    if (!rootBlocks.length) {\n      throw Error('No root blocks found')\n    }\n\n    // Keep track of the blocks that have been highlighted\n    // so that they are not highlighted again when they are connected\n    const alreadyHighlightedBlocks = new Set<string>()\n\n    this.prepareWorkspace()\n\n    for (const [i, leftMostBlock] of rootBlocks.entries()) {\n      // The first block is the root block (since rootBlocks are sorted by their path length)\n      const isRoot = i === 0\n      await this.chainBlock(leftMostBlock, alreadyHighlightedBlocks, isRoot)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}