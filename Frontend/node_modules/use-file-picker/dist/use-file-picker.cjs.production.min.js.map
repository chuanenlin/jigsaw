{"version":3,"file":"use-file-picker.cjs.production.min.js","sources":["../src/constants/bytesPerMegabyte.ts","../src/validators/fileSizeValidator/index.ts","../src/validators/filesLimitValidator/index.ts","../src/validators/imageDimensionsValidator/index.ts","../src/useFilePicker.tsx","../src/helpers/openFileDialog.ts","../src/useImperativeFilePicker.tsx","../src/validators/persistentFilesLimitValidator/index.ts"],"sourcesContent":["export const BYTES_PER_MEGABYTE = 1000000;\n","import { FileWithPath } from 'file-selector';\nimport { BYTES_PER_MEGABYTE } from '../../constants/bytesPerMegabyte';\nimport { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class FileSizeValidator implements Validator {\n  async validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { minFileSize, maxFileSize } = config;\n\n    if (!minFileSize && !maxFileSize) {\n      return Promise.resolve();\n    }\n\n    const errors = plainFiles\n      .map(file => getFileSizeError({ minFileSize, maxFileSize, fileSize: file.size }))\n      .filter(error => !!error);\n\n    return errors.length > 0 ? Promise.reject(errors[0]) : Promise.resolve();\n  }\n  async validateAfterParsing(_config: UseFilePickerConfig, _file: FileWithPath): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nconst getFileSizeError = ({\n  fileSize,\n  maxFileSize,\n  minFileSize,\n}: {\n  minFileSize: number | undefined;\n  maxFileSize: number | undefined;\n  fileSize: number;\n}) => {\n  if (minFileSize) {\n    const minBytes = minFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize < minBytes) {\n      return { fileSizeTooSmall: true };\n    }\n  }\n  if (maxFileSize) {\n    const maxBytes = maxFileSize * BYTES_PER_MEGABYTE;\n    if (fileSize > maxBytes) {\n      return { fileSizeToolarge: true };\n    }\n  }\n};\n","import { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class FilesLimitValidator implements Validator {\n  validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { limitFilesConfig } = config;\n    if (limitFilesConfig) {\n      if (limitFilesConfig.max && plainFiles.length > limitFilesConfig.max) {\n        return Promise.reject({ maxLimitExceeded: true });\n      }\n\n      if (limitFilesConfig.min && plainFiles.length < limitFilesConfig.min) {\n        return Promise.reject({ minLimitNotReached: true });\n      }\n    }\n    return Promise.resolve();\n  }\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n","import { FileWithPath } from 'file-selector';\nimport { ImageDimensionError, ImageDims, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\nexport default class ImageDimensionsValidator implements Validator {\n  validateBeforeParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n  validateAfterParsing(config: UseFilePickerConfig, file: FileWithPath, reader: FileReader): Promise<void> {\n    const { readAs, imageSizeRestrictions } = config;\n    if (readAs === 'DataURL' && imageSizeRestrictions && isImage(file.type)) {\n      return checkImageDimensions(reader.result as string, imageSizeRestrictions);\n    }\n    return Promise.resolve();\n  }\n}\n\nconst isImage = (fileType: string) => fileType.startsWith('image');\n\nconst checkImageDimensions = (imgDataURL: string, imageSizeRestrictions: ImageDims) =>\n  new Promise<void>((resolve, reject) => {\n    const img = new Image();\n    img.onload = function () {\n      const { maxHeight, maxWidth, minHeight, minWidth } = imageSizeRestrictions;\n      const { width, height } = this as unknown as typeof img;\n      let errors: ImageDimensionError = {};\n      if (maxHeight && maxHeight < height) errors = { ...errors, imageHeightTooBig: true };\n      if (minHeight && minHeight > height) errors = { ...errors, imageHeightTooSmall: true };\n      if (maxWidth && maxWidth < width) errors = { ...errors, imageWidthTooBig: true };\n      if (minWidth && minWidth > width) errors = { ...errors, imageWidthTooSmall: true };\n      Object.keys(errors).length ? reject(errors) : resolve();\n    };\n    img.onerror = function () {\n      reject({ imageNotLoaded: true } as ImageDimensionError);\n    };\n    img.src = imgDataURL;\n  });\n","import { useState, useCallback } from 'react';\nimport { fromEvent, FileWithPath } from 'file-selector';\nimport { UseFilePickerConfig, FileContent, FilePickerReturnTypes, FileError, ReaderMethod } from './interfaces';\nimport FileSizeValidator from './validators/fileSizeValidator';\nimport FilesLimitValidator from './validators/filesLimitValidator';\nimport { Validator } from './validators/validatorInterface';\nimport { openFileDialog } from './helpers/openFileDialog';\nimport ImageDimensionsValidator from './validators/imageDimensionsValidator';\n\nconst VALIDATORS: Validator[] = [new FileSizeValidator(), new FilesLimitValidator(), new ImageDimensionsValidator()];\n\nfunction useFilePicker(props: UseFilePickerConfig): FilePickerReturnTypes {\n  const {\n    accept = '*',\n    multiple = true,\n    readAs = 'Text',\n    readFilesContent = true,\n    validators = [],\n    onFilesSelected,\n    onFilesSuccessfulySelected,\n    onFilesRejected,\n    initializeWithCustomParameters,\n  } = props;\n  const [plainFiles, setPlainFiles] = useState<File[]>([]);\n  const [filesContent, setFilesContent] = useState<FileContent[]>([]);\n  const [fileErrors, setFileErrors] = useState<FileError[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const clear: () => void = useCallback(() => {\n    setPlainFiles([]);\n    setFilesContent([]);\n    setFileErrors([]);\n  }, []);\n\n  const parseFile = (file: FileWithPath) =>\n    new Promise<FileContent>(\n      async (resolve: (fileContent: FileContent) => void, reject: (reason: FileError) => void) => {\n        const reader = new FileReader();\n\n        //availible reader methods: readAsText, readAsBinaryString, readAsArrayBuffer, readAsDataURL\n        const readStrategy = reader[`readAs${readAs}` as ReaderMethod] as typeof reader.readAsText;\n        readStrategy.call(reader, file);\n\n        const addError = ({ name = file.name, ...others }: FileError) => {\n          reject({ name, fileSizeToolarge: false, fileSizeTooSmall: false, ...others });\n        };\n\n        reader.onload = async () =>\n          Promise.all(\n            VALIDATORS.concat(validators).map(validator =>\n              validator.validateAfterParsing(props, file, reader).catch(err => Promise.reject(addError(err)))\n            )\n          )\n            .then(() =>\n              resolve({\n                ...file,\n                content: reader.result as string,\n                name: file.name,\n                lastModified: file.lastModified,\n              } as FileContent)\n            )\n            .catch(() => {});\n\n        reader.onerror = () => {\n          addError({ readerError: reader.error, plainFile: file });\n        };\n      }\n    );\n\n  const openFileSelector = () => {\n    const fileExtensions = accept instanceof Array ? accept.join(',') : accept;\n    openFileDialog(\n      fileExtensions,\n      multiple,\n      async evt => {\n        clear();\n        const inputElement = evt.target as HTMLInputElement;\n        const plainFileObjects = inputElement.files ? Array.from(inputElement.files) : [];\n\n        setLoading(true);\n\n        const validations = (\n          (await Promise.all(\n            VALIDATORS.concat(validators).map(validator =>\n              validator.validateBeforeParsing(props, plainFileObjects).catch((err: FileError) => err)\n            )\n          )) as FileError[]\n        ).filter(Boolean);\n\n        setPlainFiles(plainFileObjects);\n        setFileErrors(validations);\n        if (validations.length) {\n          setLoading(false);\n          onFilesRejected?.({ errors: validations });\n          onFilesSelected?.({ errors: validations });\n          return;\n        }\n\n        if (!readFilesContent) {\n          setLoading(false);\n          onFilesSelected?.({ plainFiles: plainFileObjects, filesContent: [] });\n          return;\n        }\n\n        const files = (await fromEvent(evt)) as FileWithPath[];\n\n        const fileErrors: FileError[] = [];\n        const filesContent = (await Promise.all(\n          files.map(file =>\n            parseFile(file).catch(fileError => {\n              fileError.plainFile = file;\n              fileErrors.push(fileError);\n            })\n          )\n        )) as FileContent[];\n        setLoading(false);\n\n        if (fileErrors.length) {\n          setPlainFiles([]);\n          setFilesContent([]);\n          setFileErrors(errors => [...errors, ...fileErrors]);\n          onFilesRejected?.({ errors: fileErrors });\n          onFilesSelected?.({\n            errors: validations.concat(fileErrors),\n          });\n          return;\n        }\n\n        setFilesContent(filesContent);\n        setPlainFiles(plainFileObjects);\n        setFileErrors([]);\n        onFilesSuccessfulySelected?.({ filesContent, plainFiles: plainFileObjects });\n        onFilesSelected?.({\n          plainFiles: plainFileObjects,\n          filesContent,\n        });\n      },\n      initializeWithCustomParameters\n    );\n  };\n\n  return [openFileSelector, { filesContent, errors: fileErrors, loading, plainFiles, clear }];\n}\n\nexport default useFilePicker;\n","export function openFileDialog(\n  accept: string,\n  multiple: boolean,\n  callback: (arg: Event) => void,\n  initializeWithCustomAttributes?: (arg: HTMLInputElement) => void\n): void {\n  // this function must be called from a user\n  // activation event (ie an onclick event)\n\n  // Create an input element\n  var inputElement = document.createElement('input');\n  // Hide element and append to body (required to run on iOS safari)\n  inputElement.style.display = 'none';\n  document.body.appendChild(inputElement);\n  // Set its type to file\n  inputElement.type = 'file';\n  // Set accept to the file types you want the user to select.\n  // Include both the file extension and the mime type\n  // if accept is \"*\" then dont set the accept attribute\n  if (accept !== '*') inputElement.accept = accept;\n  // Accept multiple files\n  inputElement.multiple = multiple;\n  // set onchange event to call callback when user has selected file\n  //inputElement.addEventListener('change', callback);\n  inputElement.addEventListener('change', arg => {\n    callback(arg);\n    // remove element\n    document.body.removeChild(inputElement);\n  });\n\n  if (initializeWithCustomAttributes) {\n    initializeWithCustomAttributes(inputElement);\n  }\n  // dispatch a click event to open the file dialog\n  inputElement.dispatchEvent(new MouseEvent('click'));\n}\n","import { useCallback, useState } from 'react';\nimport { FileContent, ImperativeFilePickerReturnTypes, UseFilePickerConfig } from './interfaces';\nimport useFilePicker from './useFilePicker';\nimport persistentFileLimitValidator from './validators/persistentFilesLimitValidator';\n\n/**\n * A version of useFilePicker hook that keeps selected files between selections. On top of that it allows to remove files from the selection.\n */\nfunction useImperativeFilePicker(props: UseFilePickerConfig): ImperativeFilePickerReturnTypes {\n  const { readFilesContent, onFilesSelected, onFilesSuccessfulySelected } = props;\n\n  const [allPlainFiles, setAllPlainFiles] = useState<File[]>([]);\n  const [allFilesContent, setAllFilesContent] = useState<FileContent[]>([]);\n\n  const [open, { loading, errors, clear }] = useFilePicker({\n    ...props,\n    validators: [persistentFileLimitValidator(allPlainFiles), ...(props.validators || [])],\n    onFilesSelected: data => {\n      if (!onFilesSelected) return;\n      if (data.errors?.length) {\n        return onFilesSelected(data);\n      }\n      // override the files property to return all files that were selected previously and in the current batch\n      onFilesSelected({\n        errors: undefined,\n        plainFiles: [...allPlainFiles, ...(data.plainFiles || [])],\n        filesContent: [...allFilesContent, ...(data.filesContent || [])],\n      });\n    },\n    onFilesSuccessfulySelected: data => {\n      setAllPlainFiles(previousPlainFiles => previousPlainFiles.concat(data.plainFiles));\n      setAllFilesContent(previousFilesContent => previousFilesContent.concat(data.filesContent));\n\n      if (!onFilesSuccessfulySelected) return;\n      // override the files property to return all files that were selected previously and in the current batch\n      onFilesSuccessfulySelected({\n        plainFiles: [...allPlainFiles, ...(data.plainFiles || [])],\n        filesContent: [...allFilesContent, ...(data.filesContent || [])],\n      });\n    },\n  });\n\n  const clearPreviousFiles = useCallback(() => {\n    setAllPlainFiles([]);\n    if (readFilesContent) {\n      setAllFilesContent([]);\n    }\n  }, [readFilesContent]);\n\n  const clearAll = useCallback(() => {\n    clear();\n    clearPreviousFiles();\n  }, [clear, clearPreviousFiles]);\n\n  const removeFileByIndex = useCallback((index: number) => {\n    setAllPlainFiles(previousPlainFiles => [\n      ...previousPlainFiles.slice(0, index),\n      ...previousPlainFiles.slice(index + 1),\n    ]);\n    setAllFilesContent(previousFilesContent => [\n      ...previousFilesContent.slice(0, index),\n      ...previousFilesContent.slice(index + 1),\n    ]);\n  }, []);\n\n  const removeFileByReference = useCallback(\n    (file: File) => {\n      const index = allPlainFiles.findIndex(f => f === file);\n      if (index === -1) return;\n      removeFileByIndex(index);\n    },\n    [removeFileByIndex, allPlainFiles]\n  );\n\n  return [\n    open,\n    {\n      plainFiles: allPlainFiles,\n      filesContent: allFilesContent,\n      loading,\n      errors,\n      clear: clearAll,\n      removeFileByIndex,\n      removeFileByReference,\n    },\n  ];\n}\n\nexport default useImperativeFilePicker;\n","import { UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorInterface';\n\n/**\n * File limit validator has to be overriden to take into account the files that were previously selected\n * @param previousPlainFiles files that were previously selected\n * @returns a validator that checks if the amount of files selected previously and in the current batch is within the limits\n */\nconst persistentFileLimitValidator: (previousPlainFiles: File[]) => Validator = previousPlainFiles => ({\n  validateBeforeParsing(config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { limitFilesConfig } = config;\n    const fileAmount = previousPlainFiles.length + plainFiles.length;\n    if (limitFilesConfig) {\n      if (limitFilesConfig.max && fileAmount > limitFilesConfig.max) {\n        return Promise.reject({ maxLimitExceeded: true });\n      }\n\n      if (limitFilesConfig.min && fileAmount < limitFilesConfig.min) {\n        return Promise.reject({ minLimitNotReached: true });\n      }\n    }\n    return Promise.resolve();\n  },\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  },\n});\n\nexport default persistentFileLimitValidator;\n"],"names":["BYTES_PER_MEGABYTE","FileSizeValidator","_proto","prototype","validateBeforeParsing","_validateBeforeParsing","_asyncToGenerator","_regeneratorRuntime","mark","_callee","config","plainFiles","minFileSize","maxFileSize","errors","wrap","_context","prev","next","abrupt","Promise","resolve","map","file","getFileSizeError","fileSize","size","filter","error","length","reject","stop","_x","_x2","apply","this","arguments","validateAfterParsing","_validateAfterParsing","_callee2","_config","_file","_context2","_x3","_x4","_ref","fileSizeTooSmall","fileSizeToolarge","FilesLimitValidator","limitFilesConfig","max","maxLimitExceeded","min","minLimitNotReached","ImageDimensionsValidator","reader","imageSizeRestrictions","readAs","isImage","type","checkImageDimensions","result","fileType","startsWith","imgDataURL","img","Image","onload","maxHeight","maxWidth","minHeight","minWidth","width","height","_extends","imageHeightTooBig","imageHeightTooSmall","imageWidthTooBig","imageWidthTooSmall","Object","keys","onerror","imageNotLoaded","src","VALIDATORS","useFilePicker","props","_props$accept","accept","_props$multiple","multiple","_props$readAs","_props$readFilesConte","readFilesContent","_props$validators","validators","onFilesSelected","onFilesSuccessfulySelected","onFilesRejected","initializeWithCustomParameters","_useState","useState","setPlainFiles","_useState2","filesContent","setFilesContent","_useState3","fileErrors","setFileErrors","_useState4","loading","setLoading","clear","useCallback","parseFile","addError","FileReader","call","_ref2","_ref2$name","name","others","_objectWithoutPropertiesLoose","_excluded","all","concat","validator","err","then","content","lastModified","readerError","plainFile","callback","initializeWithCustomAttributes","inputElement","document","createElement","style","display","body","appendChild","addEventListener","arg","removeChild","dispatchEvent","MouseEvent","openFileDialog","Array","join","_ref4","_callee3","evt","plainFileObjects","validations","files","_context3","target","from","sent","Boolean","fromEvent","fileError","push","previousPlainFiles","allPlainFiles","setAllPlainFiles","allFilesContent","setAllFilesContent","_useFilePicker","persistentFileLimitValidator","fileAmount","data","_data$errors","undefined","previousFilesContent","open","_useFilePicker$","clearPreviousFiles","clearAll","removeFileByIndex","index","slice","removeFileByReference","findIndex","f"],"mappings":"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"}